
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>async-api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/psavelis/team-pro/replay-api/cmd/async-api/main.go (0.0%)</option>
				
				<option value="file1">github.com/psavelis/team-pro/replay-api/cmd/rest-api/controllers/command/file_controller.go (6.5%)</option>
				
				<option value="file2">github.com/psavelis/team-pro/replay-api/cmd/rest-api/controllers/default_search_controller.go (44.7%)</option>
				
				<option value="file3">github.com/psavelis/team-pro/replay-api/cmd/rest-api/controllers/health_controller.go (40.0%)</option>
				
				<option value="file4">github.com/psavelis/team-pro/replay-api/cmd/rest-api/controllers/query/event_controller.go (0.0%)</option>
				
				<option value="file5">github.com/psavelis/team-pro/replay-api/cmd/rest-api/controllers/query/match_controller.go (0.0%)</option>
				
				<option value="file6">github.com/psavelis/team-pro/replay-api/cmd/rest-api/controllers/query/metadata_controller.go (83.3%)</option>
				
				<option value="file7">github.com/psavelis/team-pro/replay-api/cmd/rest-api/controllers/steam_controller.go (65.6%)</option>
				
				<option value="file8">github.com/psavelis/team-pro/replay-api/cmd/rest-api/main.go (0.0%)</option>
				
				<option value="file9">github.com/psavelis/team-pro/replay-api/cmd/rest-api/middlewares/auth_middleware.go (0.0%)</option>
				
				<option value="file10">github.com/psavelis/team-pro/replay-api/cmd/rest-api/middlewares/resource_context_middleware.go (56.5%)</option>
				
				<option value="file11">github.com/psavelis/team-pro/replay-api/cmd/rest-api/routing/cors.go (0.0%)</option>
				
				<option value="file12">github.com/psavelis/team-pro/replay-api/cmd/rest-api/routing/router.go (100.0%)</option>
				
				<option value="file13">github.com/psavelis/team-pro/replay-api/pkg/app/cs/builders/match_stats_builder.go (70.6%)</option>
				
				<option value="file14">github.com/psavelis/team-pro/replay-api/pkg/app/cs/handlers/begin_new_match.go (0.0%)</option>
				
				<option value="file15">github.com/psavelis/team-pro/replay-api/pkg/app/cs/handlers/clutch_end.go (0.0%)</option>
				
				<option value="file16">github.com/psavelis/team-pro/replay-api/pkg/app/cs/handlers/clutch_progress.go (0.0%)</option>
				
				<option value="file17">github.com/psavelis/team-pro/replay-api/pkg/app/cs/handlers/clutch_start.go (0.0%)</option>
				
				<option value="file18">github.com/psavelis/team-pro/replay-api/pkg/app/cs/handlers/frag_trade.go (0.0%)</option>
				
				<option value="file19">github.com/psavelis/team-pro/replay-api/pkg/app/cs/handlers/generic_game_event.go (0.0%)</option>
				
				<option value="file20">github.com/psavelis/team-pro/replay-api/pkg/app/cs/handlers/round_mvp.go (0.0%)</option>
				
				<option value="file21">github.com/psavelis/team-pro/replay-api/pkg/app/cs/replay_file_adapter.go (88.2%)</option>
				
				<option value="file22">github.com/psavelis/team-pro/replay-api/pkg/app/cs/state/cs_clutch_context.go (42.9%)</option>
				
				<option value="file23">github.com/psavelis/team-pro/replay-api/pkg/app/cs/state/cs_match_context.go (73.0%)</option>
				
				<option value="file24">github.com/psavelis/team-pro/replay-api/pkg/app/cs/state/cs_round_context.go (33.3%)</option>
				
				<option value="file25">github.com/psavelis/team-pro/replay-api/pkg/domain/base_query_service.go (0.0%)</option>
				
				<option value="file26">github.com/psavelis/team-pro/replay-api/pkg/domain/cs/entities/cs_match_stats.go (100.0%)</option>
				
				<option value="file27">github.com/psavelis/team-pro/replay-api/pkg/domain/cs/entities/cs_player_stats.go (55.6%)</option>
				
				<option value="file28">github.com/psavelis/team-pro/replay-api/pkg/domain/entity.go (0.0%)</option>
				
				<option value="file29">github.com/psavelis/team-pro/replay-api/pkg/domain/game.go (100.0%)</option>
				
				<option value="file30">github.com/psavelis/team-pro/replay-api/pkg/domain/iam/entities/rid.go (0.0%)</option>
				
				<option value="file31">github.com/psavelis/team-pro/replay-api/pkg/domain/iam/use_cases/create_rid_token.go (12.5%)</option>
				
				<option value="file32">github.com/psavelis/team-pro/replay-api/pkg/domain/iam/use_cases/verify_rid_key.go (5.3%)</option>
				
				<option value="file33">github.com/psavelis/team-pro/replay-api/pkg/domain/replay/entities/game_event.go (0.0%)</option>
				
				<option value="file34">github.com/psavelis/team-pro/replay-api/pkg/domain/replay/entities/match.go (0.0%)</option>
				
				<option value="file35">github.com/psavelis/team-pro/replay-api/pkg/domain/replay/entities/player.go (0.0%)</option>
				
				<option value="file36">github.com/psavelis/team-pro/replay-api/pkg/domain/replay/entities/replay_file.go (0.0%)</option>
				
				<option value="file37">github.com/psavelis/team-pro/replay-api/pkg/domain/replay/services/metadata/event_query_service.go (0.0%)</option>
				
				<option value="file38">github.com/psavelis/team-pro/replay-api/pkg/domain/replay/services/metadata/match_query_service.go (0.0%)</option>
				
				<option value="file39">github.com/psavelis/team-pro/replay-api/pkg/domain/replay/services/metadata/replay_file_query_service.go (100.0%)</option>
				
				<option value="file40">github.com/psavelis/team-pro/replay-api/pkg/domain/replay/use_cases/process_replay_file.go (2.7%)</option>
				
				<option value="file41">github.com/psavelis/team-pro/replay-api/pkg/domain/replay/use_cases/update_replay_file_header.go (5.0%)</option>
				
				<option value="file42">github.com/psavelis/team-pro/replay-api/pkg/domain/replay/use_cases/upload_and_process_replay_file_usecase.go (7.1%)</option>
				
				<option value="file43">github.com/psavelis/team-pro/replay-api/pkg/domain/replay/use_cases/upload_replay_file_usecase.go (3.7%)</option>
				
				<option value="file44">github.com/psavelis/team-pro/replay-api/pkg/domain/resource_owner.go (0.0%)</option>
				
				<option value="file45">github.com/psavelis/team-pro/replay-api/pkg/domain/search.go (67.0%)</option>
				
				<option value="file46">github.com/psavelis/team-pro/replay-api/pkg/domain/steam/entities/steam_user.go (0.0%)</option>
				
				<option value="file47">github.com/psavelis/team-pro/replay-api/pkg/domain/steam/errors.go (0.0%)</option>
				
				<option value="file48">github.com/psavelis/team-pro/replay-api/pkg/domain/steam/use_cases/onboard-steam-user.go (48.6%)</option>
				
				<option value="file49">github.com/psavelis/team-pro/replay-api/pkg/infra/blob/local/local.go (0.0%)</option>
				
				<option value="file50">github.com/psavelis/team-pro/replay-api/pkg/infra/clients/steam_client.go (0.0%)</option>
				
				<option value="file51">github.com/psavelis/team-pro/replay-api/pkg/infra/crypto/vhasher_adapter.go (100.0%)</option>
				
				<option value="file52">github.com/psavelis/team-pro/replay-api/pkg/infra/db/events_mongodb.go (0.0%)</option>
				
				<option value="file53">github.com/psavelis/team-pro/replay-api/pkg/infra/db/match_metadata_mongodb.go (100.0%)</option>
				
				<option value="file54">github.com/psavelis/team-pro/replay-api/pkg/infra/db/mongodb_repository.go (55.3%)</option>
				
				<option value="file55">github.com/psavelis/team-pro/replay-api/pkg/infra/db/replay_file_content_mongodb.go (0.0%)</option>
				
				<option value="file56">github.com/psavelis/team-pro/replay-api/pkg/infra/db/replay_file_metadata_mongodb.go (100.0%)</option>
				
				<option value="file57">github.com/psavelis/team-pro/replay-api/pkg/infra/db/rid_mongodb.go (0.0%)</option>
				
				<option value="file58">github.com/psavelis/team-pro/replay-api/pkg/infra/db/steam_user_mongodb.go (0.0%)</option>
				
				<option value="file59">github.com/psavelis/team-pro/replay-api/pkg/infra/events/pub_rabbit.go (0.0%)</option>
				
				<option value="file60">github.com/psavelis/team-pro/replay-api/pkg/infra/ioc/container.go (60.8%)</option>
				
				<option value="file61">github.com/psavelis/team-pro/replay-api/pkg/infra/ioc/environment.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "log"

        "github.com/streadway/amqp"
)

func failOnError(err error, msg string) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("%s: %s", msg, err)
        }</span>
}

func main() <span class="cov0" title="0">{
        conn, err := amqp.Dial("amqp://rabbitmq:rabbitmq@localhost:5778/")
        failOnError(err, "Failed to connect to RabbitMQ")
        defer conn.Close()

        ch, err := conn.Channel()
        failOnError(err, "Failed to open a channel")
        defer ch.Close()

        q, err := ch.QueueDeclare(
                "hello", // name
                false,   // durable
                false,   // delete when unused
                false,   // exclusive
                false,   // no-wait
                nil,     // arguments
        )
        failOnError(err, "Failed to declare a queue")

        msgs, err := ch.Consume(
                q.Name, // queue
                "",     // consumer
                true,   // auto-ack
                false,  // exclusive
                false,  // no-local
                false,  // no-wait
                nil,    // args
        )
        failOnError(err, "Failed to register a consumer")

        f := make(chan bool)

        go func() </span><span class="cov0" title="0">{
                for d := range msgs </span><span class="cov0" title="0">{
                        log.Printf("Received a message: %s", d.Body)
                }</span>
        }()

        <span class="cov0" title="0">log.Printf(" [*] Waiting for messages. To exit press CTRL+C")
        &lt;-f</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd_controllers

import (
        "context"
        "encoding/json"
        "log/slog"
        "net/http"

        "github.com/golobby/container/v3"
        common "github.com/psavelis/team-pro/replay-api/pkg/domain"
        replay_in "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/ports/in"
)

type FileController struct {
        container container.Container
}

func NewFileController(container container.Container) *FileController <span class="cov10" title="2">{
        return &amp;FileController{container: container}
}</span>

func (ctlr *FileController) UploadHandler(apiContext context.Context) http.HandlerFunc <span class="cov10" title="2">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Access-Control-Allow-Origin", "localhost:3000")
                w.Header().Set("Access-Control-Allow-Methods", "POST")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
                // r.Body = http.MaxBytesReader(w, r.Body, 32&lt;&lt;20)
                r.ParseMultipartForm(32 &lt;&lt; 50)

                reqContext := context.WithValue(r.Context(), common.GameIDParamKey, r.FormValue("game_id"))

                file, _, err := r.FormFile("file")
                if err != nil </span><span class="cov0" title="0">{
                        slog.ErrorContext(reqContext, "Failed to get file", err)
                        w.WriteHeader(http.StatusBadRequest)
                        return
                }</span>
                <span class="cov0" title="0">defer file.Close()

                var uploadAndProcessReplayFileCommand replay_in.UploadAndProcessReplayFileCommand
                err = ctlr.container.Resolve(&amp;uploadAndProcessReplayFileCommand)
                if err != nil </span><span class="cov0" title="0">{
                        slog.ErrorContext(reqContext, "Failed to resolve uploadAndProcessReplayFileCommand", err)
                        w.WriteHeader(http.StatusServiceUnavailable)
                        return
                }</span>

                <span class="cov0" title="0">match, err := uploadAndProcessReplayFileCommand.Exec(reqContext, file)
                if err != nil </span><span class="cov0" title="0">{
                        slog.ErrorContext(reqContext, "Failed to upload and process file", err)
                        w.WriteHeader(http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">match.Events = nil

                err = json.NewEncoder(w).Encode(match)
                if err != nil </span><span class="cov0" title="0">{
                        slog.ErrorContext(reqContext, "Failed to encode response", err, "match", match)
                        w.WriteHeader(http.StatusBadGateway)
                }</span>

                <span class="cov0" title="0">w.Header().Set("Location", r.URL.Path+"/"+match.ID.String())
                w.WriteHeader(http.StatusCreated)</span>
        }
}

// func (ctlr *FileController) ReplayMetadataFilterHandler(apiContext context.Context) http.HandlerFunc {
//         return func(w http.ResponseWriter, r *http.Request) {
//                 w.Header().Set("Access-Control-Allow-Origin", "localhost:3000")
//                 w.Header().Set("Access-Control-Allow-Methods", "GET")
//                 w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

//                 reqContext := context.WithValue(r.Context(), common.GameIDParamKey, r.FormValue("game_id"))

//                 var replayFileMetadataReader replay_in.ReplayFileMetadataReader
//                 err := ctlr.container.Resolve(&amp;replayFileMetadataReader)
//                 if err != nil {
//                         slog.ErrorContext(reqContext, "Failed to resolve replayFileMetadataReader", err)
//                         w.WriteHeader(http.StatusServiceUnavailable)
//                         return
//                 }

//                 var params []common.SearchAggregation

//                 // for key, values := range r.URL.Query() {
//                 //         params = append(params, common.SearchAggregation{
//                 //                 Key:    key,
//                 //                 Values: values,
//                 //         })
//                 // }

//                 // replayFiles, err := replayFileMetadataReader.Filter(reqContext, r.URL.Query())
//                 // if err != nil {
//                 //         slog.ErrorContext(reqContext, "Failed to get replay files", err)
//                 //         w.WriteHeader(http.StatusInternalServerError)
//                 //         return
//                 // }

//                 // err = json.NewEncoder(w).Encode(replayFiles)
//                 // if err != nil {
//                 //         slog.ErrorContext(reqContext, "Failed to encode response", err, "replayFiles", replayFiles)
//                 //         w.WriteHeader(http.StatusBadGateway)
//                 // }

//                 // w.Header().Set("Location", r.URL.Path)
//                 // w.WriteHeader(http.StatusOK)
//         }
// }
</pre>
		
		<pre class="file" id="file2" style="display: none">package controllers

import (
        "encoding/base64"
        "encoding/json"
        "log/slog"
        "net/http"

        common "github.com/psavelis/team-pro/replay-api/pkg/domain"
)

type DefaultSearchController[T any] struct {
        common.Searchable[T]
}

func NewDefaultSearchController[T any](service common.Searchable[T]) *DefaultSearchController[T] <span class="cov10" title="5">{
        return &amp;DefaultSearchController[T]{
                service,
        }
}</span>

func (c *DefaultSearchController[T]) DefaultSearchHandler(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        base64SearchHeader := r.Header.Get("x-search")
        if base64SearchHeader == "" </span><span class="cov0" title="0">{
                slog.Error("(DefaultSearchHandler) No search source provided: missing 'x-search' in request header")
                w.WriteHeader(http.StatusBadRequest)
                return
        }</span>

        <span class="cov1" title="1">searchJSON, err := base64.StdEncoding.DecodeString(base64SearchHeader)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("(DefaultSearchHandler) Error decoding search source base64 header", "error", err)
                w.WriteHeader(http.StatusBadRequest)
                return
        }</span>

        <span class="cov1" title="1">var s common.Search

        err = json.Unmarshal([]byte(searchJSON), &amp;s)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("(DefaultSearchHandler) Error unmarshalling search source", "error", err, "searchJSON", searchJSON, "base64SearchHeader", base64SearchHeader)
                w.WriteHeader(http.StatusBadRequest)
                return
        }</span>

        <span class="cov1" title="1">if s.SearchParams == nil </span><span class="cov0" title="0">{
                slog.Error("(DefaultSearchHandler) Empty search source provided")
                w.WriteHeader(http.StatusBadRequest)
                return
        }</span>

        <span class="cov1" title="1">compiledSearch, err := c.Compile(r.Context(), s.SearchParams, s.ResultOptions)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("(DefaultSearchHandler) Error validating search request", "error", err)
                w.WriteHeader(http.StatusBadRequest)
                return
        }</span>

        <span class="cov1" title="1">if compiledSearch == nil </span><span class="cov0" title="0">{
                slog.Error("(DefaultSearchHandler) Error validating search request", "error", "search is nil")
                w.WriteHeader(http.StatusUnprocessableEntity)
                return
        }</span>

        <span class="cov1" title="1">results, err := c.Search(r.Context(), *compiledSearch)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("(DefaultSearchHandler) Error filtering search request", "error", err)
                w.WriteHeader(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(results)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package controllers

import (
        "context"
        "encoding/json"
        "net/http"

        "github.com/golobby/container/v3"
)

type HealthController struct {
        Container container.Container
}

func NewHealthController(container container.Container) *HealthController <span class="cov10" title="2">{
        return &amp;HealthController{Container: container}
}</span>

func (hc *HealthController) HealthCheck(apiContext context.Context) http.HandlerFunc <span class="cov10" title="2">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusOK)

                json.NewEncoder(w).Encode(`{ status: "ok" }`)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package query_controllers

import (
        "github.com/golobby/container/v3"
        controllers "github.com/psavelis/team-pro/replay-api/cmd/rest-api/controllers"
        replay_entity "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/entities"
        replay_in "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/ports/in"
)

type EventQueryController struct {
        controllers.DefaultSearchController[replay_entity.GameEvent]
}

func NewEventQueryController(c container.Container) *EventQueryController <span class="cov0" title="0">{
        var queryService replay_in.EventReader

        err := c.Resolve(&amp;queryService)

        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">baseController := controllers.NewDefaultSearchController(queryService)

        return &amp;EventQueryController{*baseController}</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package query_controllers

import (
        "github.com/golobby/container/v3"
        controllers "github.com/psavelis/team-pro/replay-api/cmd/rest-api/controllers"
        replay_entity "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/entities"
        replay_in "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/ports/in"
)

type MatchQueryController struct {
        controllers.DefaultSearchController[replay_entity.Match]
}

func NewMatchQueryController(c container.Container) *MatchQueryController <span class="cov0" title="0">{
        var queryService replay_in.MatchReader

        err := c.Resolve(&amp;queryService)

        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">baseController := controllers.NewDefaultSearchController(queryService)

        return &amp;MatchQueryController{*baseController}</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package query_controllers

import (
        "github.com/golobby/container/v3"

        controllers "github.com/psavelis/team-pro/replay-api/cmd/rest-api/controllers"
        replay_entity "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/entities"
        replay_in "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/ports/in"
)

type ReplayMetadataQueryController struct {
        controllers.DefaultSearchController[replay_entity.ReplayFile]
}

func NewReplayMetadataQueryController(container container.Container) *ReplayMetadataQueryController <span class="cov8" title="1">{
        var replayFileMetadataReader replay_in.ReplayFileMetadataReader

        err := container.Resolve(&amp;replayFileMetadataReader)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">baseController := controllers.NewDefaultSearchController(replayFileMetadataReader)

        return &amp;ReplayMetadataQueryController{
                *baseController,
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package controllers

import (
        "context"
        "encoding/json"
        "log/slog"
        "net/http"

        "github.com/golobby/container/v3"
        steam_entity "github.com/psavelis/team-pro/replay-api/pkg/domain/steam/entities"
        steam_in "github.com/psavelis/team-pro/replay-api/pkg/domain/steam/ports/in"
)

type SteamController struct {
        OnboardSteamUserCommand steam_in.OnboardSteamUserCommand
}

func NewSteamController(container *container.Container) *SteamController <span class="cov10" title="2">{
        var onboardSteamUserCommand steam_in.OnboardSteamUserCommand
        err := container.Resolve(&amp;onboardSteamUserCommand)

        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Cannot resolve steam_in.OnboardSteamUserCommand for new SteamController", "err", err)
                panic(err)</span>
        }

        <span class="cov10" title="2">return &amp;SteamController{OnboardSteamUserCommand: onboardSteamUserCommand}</span>
}

func (c *SteamController) OnboardSteamUser(apiContext context.Context) http.HandlerFunc <span class="cov10" title="2">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="2">{
                w.Header().Set("Access-Control-Allow-Origin", "localhost:3000")
                w.Header().Set("Access-Control-Allow-Methods", "POST")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

                if r.Body == nil </span><span class="cov1" title="1">{
                        http.Error(w, "Bad Request", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov1" title="1">decoder := json.NewDecoder(r.Body)
                var steamUserParams steam_entity.SteamUser
                err := decoder.Decode(&amp;steamUserParams)

                if err != nil </span><span class="cov0" title="0">{
                        slog.ErrorContext(r.Context(), "error decoding steam user from request", err)
                        http.Error(w, "Bad Request", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov1" title="1">err = c.OnboardSteamUserCommand.Validate(r.Context(), steamUserParams.Steam.ID, steamUserParams.VHash)

                if err != nil </span><span class="cov0" title="0">{
                        slog.ErrorContext(r.Context(), "error validating steam user", err, "steamUserParams", steamUserParams)
                        http.Error(w, "Bad Request", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov1" title="1">steamUser, err := c.OnboardSteamUserCommand.Exec(r.Context(), steamUserParams.Steam.ID, steamUserParams.VHash)

                if err != nil </span><span class="cov0" title="0">{
                        slog.ErrorContext(r.Context(), "error onboarding steam user", err)
                        http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov1" title="1">w.WriteHeader(http.StatusCreated)
                json.NewEncoder(w).Encode(steamUser)</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "context"
        "log/slog"
        "net/http"
        "os"

        //        "golang.org/x/oauth2/jwt"

        "github.com/psavelis/team-pro/replay-api/cmd/rest-api/routing"
        ioc "github.com/psavelis/team-pro/replay-api/pkg/infra/ioc"
)

func main() <span class="cov0" title="0">{
        ctx := context.Background()

        logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))

        slog.SetDefault(logger)

        c := ioc.NewContainerBuilder().WithEnvFile().With(ioc.InjectMongoDB).WithInboundPorts().Build()

        router := routing.NewRouter(ctx, c)

        slog.InfoContext(ctx, "Starting server on port 4991")

        http.ListenAndServe(":4991", router)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// implement a go mux middleware that receives the Bearer Token of a steam account, and validate it against: https://api.steampowered.com/ISteamUserOAuth/GetTokenDetails/v1/?access_token=token in and add the steamID to context

package middlewares

import (
        "context"
        "net/http"
        "strings"
)

type AuthMiddleware struct {
}

func NewAuthMiddleware() *AuthMiddleware <span class="cov0" title="0">{
        return &amp;AuthMiddleware{}
}</span>

func (am *AuthMiddleware) Handler(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                authorizationHeader := r.Header.Get("Authorization")
                if authorizationHeader == "" </span><span class="cov0" title="0">{
                        http.Error(w, "no-auth", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov0" title="0">bearerToken := strings.Split(authorizationHeader, "Bearer ")
                if len(bearerToken) != 2 </span><span class="cov0" title="0">{
                        http.Error(w, "no-auth", http.StatusUnauthorized)
                        return
                }</span>

                // TODO: remover bypass
                // TODO review!!
                // steamToken := bearerToken[1]

                // steamID, err := getSteamID(steamToken)
                // if err != nil {
                //         http.Error(w, "Failed to validate token", http.StatusUnauthorized)
                //         return
                // }

                // ctx := context.WithValue(r.Context(), "steamID", steamID)
                <span class="cov0" title="0">next.ServeHTTP(w, r.WithContext(context.Background()))</span>
        })
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package middlewares

import (
        "context"
        "log/slog"
        "net/http"

        "github.com/golobby/container/v3"
        "github.com/google/uuid"
        common "github.com/psavelis/team-pro/replay-api/pkg/domain"
        iam_in "github.com/psavelis/team-pro/replay-api/pkg/domain/iam/ports/in"
)

type ResourceContextMiddleware struct {
        VerifyRID iam_in.VerifyRIDKeyCommand
}

func NewResourceContextMiddleware(container *container.Container) *ResourceContextMiddleware <span class="cov10" title="2">{
        var verifyRID iam_in.VerifyRIDKeyCommand
        err := container.Resolve(&amp;verifyRID)

        if err != nil </span><span class="cov0" title="0">{
                slog.Error("unable to resolve VerifyRIDKeyCommand")
        }</span>

        <span class="cov10" title="2">return &amp;ResourceContextMiddleware{
                VerifyRID: verifyRID,
        }</span>
}

func (m *ResourceContextMiddleware) Handler(next http.Handler) http.Handler <span class="cov10" title="2">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="2">{
                ctx := context.WithValue(r.Context(), common.TenantIDKey, common.TeamPROTenantID)
                ctx = context.WithValue(ctx, common.ClientIDKey, common.TeamPROAppClientID)
                ctx = context.WithValue(ctx, common.GroupIDKey, uuid.New())
                ctx = context.WithValue(ctx, common.UserIDKey, uuid.New())

                rid := r.Header.Get("X-Resource-Owner-ID")
                if rid == "" </span><span class="cov10" title="2">{
                        next.ServeHTTP(w, r.WithContext(ctx))
                        return
                }</span>

                <span class="cov0" title="0">reso, err := m.VerifyRID.Exec(ctx, uuid.MustParse(rid))
                if err != nil </span><span class="cov0" title="0">{
                        slog.ErrorContext(ctx, "unable to verify rid", "X-Resource-Owner-ID", rid)
                        http.Error(w, "unknown", http.StatusUnauthorized)
                }</span>

                <span class="cov0" title="0">if !reso.IsUser() </span><span class="cov0" title="0">{
                        slog.WarnContext(ctx, "non end user resource owner", "reso", reso)
                }</span>

                <span class="cov0" title="0">ctx = context.WithValue(ctx, common.GroupIDKey, reso.GroupID)
                ctx = context.WithValue(ctx, common.UserIDKey, reso.UserID)

                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package routing

import "net/http"

func EnableCors(w *http.ResponseWriter) <span class="cov0" title="0">{
        (*w).Header().Set("Access-Control-Allow-Origin", "*")
        (*w).Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        (*w).Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
}</span>

func OptionsHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        EnableCors(&amp;w)
        w.WriteHeader(http.StatusOK)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package routing

import (
        "context"
        "net/http"

        "github.com/golobby/container/v3"
        "github.com/gorilla/mux"
        "github.com/psavelis/team-pro/replay-api/cmd/rest-api/controllers"
        cmd_controllers "github.com/psavelis/team-pro/replay-api/cmd/rest-api/controllers/command"
        query_controllers "github.com/psavelis/team-pro/replay-api/cmd/rest-api/controllers/query"
        "github.com/psavelis/team-pro/replay-api/cmd/rest-api/middlewares"
)

const (
        Health       string = "/healthz"
        Match        string = "/games/{game_id}/match"
        MatchDetail  string = "/games/{game_id}/match/{match_id}"
        MatchEvent   string = "/games/{game_id}/match/{match_id}/events"
        GameEvents   string = "/games/{game_id}/events"
        Replay       string = "/games/{game_id}/replay"
        ReplayDetail string = "/games/{game_id}/replay/{replay_file_id}"
        Onboard      string = "/onboarding"
        OnboardSteam string = "/onboarding/steam"
)

func NewRouter(ctx context.Context, container container.Container) http.Handler <span class="cov10" title="2">{
        // middleware
        resourceContextMiddleware := middlewares.NewResourceContextMiddleware(&amp;container)

        // metadataController := controllers.NewMetadataController(container)
        fileController := cmd_controllers.NewFileController(container)
        healthController := controllers.NewHealthController(container)
        steamController := controllers.NewSteamController(&amp;container)
        matchController := query_controllers.NewMatchQueryController(container)
        eventController := query_controllers.NewEventQueryController(container)

        r := mux.NewRouter()
        r.Use(mux.CORSMethodMiddleware(r))
        r.Use(resourceContextMiddleware.Handler)

        // r.Use(middlewares.NewLoggerMiddleware().Handler)
        // r.Use(middlewares.NewRecoveryMiddleware().Handler)
        // r.Use(middlewares.NewResourceContextMiddleware().Handler)
        // r.Use(middlewares.NewAuthMiddleware().Handler)

        // cors

        // health
        r.HandleFunc(Health, healthController.HealthCheck(ctx)).Methods("GET")

        // onboarding/steam
        r.HandleFunc(OnboardSteam, steamController.OnboardSteamUser(ctx)).Methods("POST")

        // Matches API
        // r.HandleFunc(MatchEvent, metadataController.GetEventsByGameIDAndMatchID(ctx)).Methods("GET") // DEPRECATED

        // r.HandleFunc("/games/{game_id}/matches/{match_id}/share", metadataController.GetEventsByGameIDAndMatchID(ctx)).Methods("POST")
        // r.HandleFunc("/games/{game_id}/matches", metadataController.GetMatchesByGameID(ctx)).Methods("GET") // ?userID=123&amp;gameID=123&amp;matchID=123

        // Replay API
        r.HandleFunc(Replay, fileController.UploadHandler(ctx)).Methods("POST")
        r.HandleFunc(Replay, OptionsHandler).Methods("OPTIONS") // TODO: remover
        // r.HandleFunc(Replay, metadataController.ReplaySearchHandler(ctx)).Methods("GET")
        r.HandleFunc(Match, matchController.DefaultSearchHandler).Methods("GET")

        // Game Events API
        r.HandleFunc(GameEvents, eventController.DefaultSearchHandler).Methods("GET")

        // r.HandleFunc(ReplayDetail, fileController.ReplayDetailHandler(ctx)).Methods("GET")
        // r.HandleFunc(("/games/{game_id}/replay/{replay_file_id}"), fileController.ProcessReplayFile(ctx)).Methods("PUT")
        // r.HandleFunc(("/games/{game_id}/replay/{replay_file_id}/metadata"), fileController.GetReplayFile(ctx)).Methods("GET")
        // r.HandleFunc(("/games/{game_id}/replay/{replay_file_id}/download"), fileController.DownloadReplayFile(ctx)).Methods("GET")

        // Sharing API
        // r.HandleFunc(("/games/{game_id}/replay/{replay_file_id}/share"), fileController.DownloadReplayFile(ctx)).Methods("POST")
        // r.HandleFunc(("/games/{game_id}/replay/{replay_file_id}/share"), fileController.DownloadReplayFile(ctx)).Methods("GET")
        // r.HandleFunc(("/games/{game_id}/replay/{replay_file_id}/share/{share_token_id}"), fileController.DownloadReplayFile(ctx)).Methods("DELETE")

        // Squad API
        // r.HandleFunc("/games/{game_id}/squad", squadController.GetSquadByGameID(ctx)).Methods("GET")
        // r.HandleFunc("/games/{game_id}/squad", squadController.CreateSquad(ctx)).Methods("POST")
        // r.HandleFunc("/games/{game_id}/squad/{squad_id}", squadController.GetSquadByID(ctx)).Methods("GET")
        // r.HandleFunc("/games/{game_id}/squad/{squad_id}", squadController.UpdateSquad(ctx)).Methods("PUT")
        // r.HandleFunc("/games/{game_id}/squad/{squad_id}", squadController.DeleteSquad(ctx)).Methods("DELETE")

        // User API
        // r.HandleFunc("/games/{game_id}/user", userController.GetUserByGameID(ctx)).Methods("GET")
        // r.HandleFunc("/games/{game_id}/user", userController.CreateUser(ctx)).Methods("POST")
        // r.HandleFunc("/games/{game_id}/user/{user_id}", userController.GetUserByID(ctx)).Methods("GET")
        // r.HandleFunc("/games/{game_id}/user/{user_id}", userController.UpdateUser(ctx)).Methods("PUT")
        // r.HandleFunc("/games/{game_id}/user/{user_id}", userController.DeleteUser(ctx)).Methods("DELETE")

        // Badges API
        // r.HandleFunc("/games/{game_id}/badges", badgeController.GetBadgesByGameID(ctx)).Methods("GET")
        // r.HandleFunc("/games/{game_id}/badge_types", badgeController.GetBadgeTypes(ctx)).Methods("GET")
        // r.HandleFunc("/games/{game_id}/badges/{badge_id}", badgeController.GetBadgeByID(ctx)).Methods("GET")
        // r.HandleFunc("/games/{game_id}/badges/{badge_id}", badgeController.UpdateBadge(ctx)).Methods("PUT")
        // r.HandleFunc("/games/{game_id}/badges/{badge_id}", badgeController.DeleteBadge(ctx)).Methods("DELETE")

        // Stats API
        // r.HandleFunc("/games/{game_id}/stats", statsController.GetStatsByGameID(ctx)).Methods("GET")

        // Leaderboard API
        // r.HandleFunc("/games/{game_id}/leaderboard", leaderboardController.GetLeaderboardByGameID(ctx)).Methods("GET")

        // Game API
        // r.HandleFunc("/games/{game_id}", gameController.GetGameByID(ctx)).Methods("GET")

        return r
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package builders

import (
        "log/slog"
        "strconv"

        dem "github.com/markus-wa/demoinfocs-golang/v4/pkg/demoinfocs"
        cs2 "github.com/markus-wa/demoinfocs-golang/v4/pkg/demoinfocs/common"
        "github.com/psavelis/team-pro/replay-api/pkg/app/cs/state"
        e "github.com/psavelis/team-pro/replay-api/pkg/domain/cs/entities"
)

type CS2MatchStatsBuilder struct {
        MatchContext *state.CS2MatchContext
        MatchStats   e.CSMatchStats
        Parser       dem.Parser
}

func NewCSMatchStatsBuilder(p dem.Parser, matchContext *state.CS2MatchContext) *CS2MatchStatsBuilder <span class="cov5" title="73">{
        return &amp;CS2MatchStatsBuilder{
                Parser:       p,
                MatchContext: matchContext,
                MatchStats:   e.NewCSMatchStats(matchContext.MatchID, matchContext.ResourceOwner, len(matchContext.RoundContexts)),
        }
}</span>

func (builder *CS2MatchStatsBuilder) WithRoundsStats(RoundContexts map[int]state.CS2RoundContext) *CS2MatchStatsBuilder <span class="cov5" title="73">{
        for _, v := range RoundContexts </span><span class="cov7" title="915">{
                builder = builder.withRoundStats(v)
        }</span>

        <span class="cov5" title="73">return builder</span>
}

func (builder *CS2MatchStatsBuilder) StatsFromPlayer(roundIndex int, player cs2.Player) e.CSPlayerStats <span class="cov10" title="13017">{
        // return e.CSPlayerStats{}

        // TODO: IMPLEMENTAR CONTEXTO DE TRADE!
        trades := min(player.Kills(), player.Deaths(), player.Assists())

        return e.CSPlayerStats{
                NetworkPlayerID:   strconv.Itoa(player.UserID),
                Kills:             player.Kills(),
                Deaths:            player.Deaths(),
                Assists:           player.Assists(),
                TotalDamage:       player.TotalDamage(),
                TotalRoundsPlayed: roundIndex, // TODO: isso nao Ã© verdade, pois pode ter se deconectado em algum momento, revisar!
                ADR:               e.CalculateADR(player.TotalDamage(), roundIndex+1),
                // Headshots:         player.Headshots(),
                LastAlivePosition: player.LastAlivePosition,
                // Inventory:         player.Inventory,
                TradeFrags:         trades,
                DeathsToKillsRatio: e.CalculateKDR(player.Deaths(), player.Kills()),
                // KAST:       e.CalculateKAST(player.Kills(), player.Assists(), roundContext.RoundNumber-player.Deaths(), trades, roundContext.RoundNumber),
                // TODO: fork do demoinfo e adicionar esses campos:
                //         Headshots          int        `json:"headshots" bson:"headshots"`                         // Headshots is the number of kills a player gets by shooting an enemy in the head
                //         EntryFrags         int        `json:"entry_frags" bson:"entry_frags"`                     // EntryFrags is the number of kills a player gets when they are the first to kill an enemy
                //         TradeFrags         int        `json:"trade_frags" bson:"trade_frags"`                     // TradeFrags is the number of kills a player gets when they are the second to kill an enemy
                //         FirstKills         int        `json:"first_kills" bson:"first_kills"`                     // FirstKills is the number of times a player gets the first kill in a round
                //         Clutches           int        `json:"clutches" bson:"clutches"`                           // Clutches is the number of times a player wins a round when they are the last player alive
                //         Flashes            int        `json:"flashes" bson:"flashes"`                             // Flashes is the number of times a player flashes an enemy
                //         DeathsToKillsRatio float64    `json:"deaths_to_kills_ratio" bson:"deaths_to_kills_ratio"` // DeathsToKillsRatio is the ratio of deaths to kills
                // }

        }
}</span>

func (builder *CS2MatchStatsBuilder) withRoundStats(roundContext state.CS2RoundContext) *CS2MatchStatsBuilder <span class="cov7" title="915">{
        if roundContext.RoundNumber == 0 </span><span class="cov0" title="0">{
                msg := "round number cannot be 0"
                slog.Error(msg)
                panic(msg)</span>
        }

        <span class="cov7" title="915">if roundContext.RoundNumber &gt; len(builder.MatchContext.RoundContexts) </span><span class="cov0" title="0">{
                msg := "round number is greater than the total number of rounds"
                slog.Error(msg)
                panic(msg)</span>
        }

        <span class="cov7" title="915">if roundContext.RoundNumber &lt; 0 </span><span class="cov0" title="0">{
                msg := "round number cannot be negative"
                slog.Error(msg)
                panic(msg)</span>
        }

        <span class="cov7" title="915">roundIndex := roundContext.RoundNumber - 1

        // refact-to-round-builder-------- withClutchStats
        var clutchStats *e.CSClutchStats

        currentClutch := roundContext.GetClutch()
        if currentClutch != nil &amp;&amp; currentClutch.GetPlayer() != nil </span><span class="cov7" title="895">{
                clutchStats = &amp;e.CSClutchStats{
                        RoundNumber:     roundContext.RoundNumber,
                        NetworkPlayerID: currentClutch.GetNetworkPlayerID(),
                        Status:          roundContext.GetClutch().Status,
                        OpponentsStats:  make([]e.CSPlayerStats, len(currentClutch.GetOpponents())),
                }

                for i, opponent := range roundContext.GetClutch().GetOpponents() </span><span class="cov8" title="2879">{
                        clutchStats.OpponentsStats[i] = builder.StatsFromPlayer(roundIndex, opponent)
                }</span>
        } else<span class="cov3" title="20"> {
                clutchStats = &amp;e.CSClutchStats{
                        RoundNumber: roundContext.RoundNumber,
                        Status:      e.NotInClutchSituation,
                }
        }</span>
        // refact-to-round-builder-------- withClutchStats

        <span class="cov7" title="915">participants := builder.Parser.GameState().Participants().All()

        playerStats := make([]e.CSPlayerStats, len(participants))

        for i, player := range participants </span><span class="cov9" title="10065">{
                playerStats[i] = builder.StatsFromPlayer(roundIndex, *player)
        }</span>

        <span class="cov7" title="915">builder.MatchStats.RoundsStats[roundIndex] = e.CSRoundStats{
                RoundNumber:         roundContext.RoundNumber,
                WinnerNetworkTeamID: roundContext.WinnerNetworkTeamID,
                PlayersStats:        playerStats,
                ClutchStats:         clutchStats,
        }

        return builder</span>
}

func (builder *CS2MatchStatsBuilder) Build() e.CSMatchStats <span class="cov5" title="73">{
        return builder.MatchStats
}</span>

func (builder *CS2MatchStatsBuilder) BuildWithHeader() e.CSMatchStats <span class="cov0" title="0">{
        return e.CSMatchStats{
                MatchID:       builder.MatchStats.MatchID,
                GameState:     builder.MatchStats.GameState,
                Rules:         builder.MatchStats.Rules,
                RoundsStats:   builder.MatchStats.RoundsStats,
                ResourceOwner: builder.MatchStats.ResourceOwner,
                Header:        &amp;builder.MatchContext.Header,
        }
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package handlers

import (
        "context"

        "github.com/google/uuid"
        dem "github.com/markus-wa/demoinfocs-golang/v4/pkg/demoinfocs"
        evt "github.com/markus-wa/demoinfocs-golang/v4/pkg/demoinfocs/events"
        "github.com/psavelis/team-pro/replay-api/pkg/app/cs/builders"
        state "github.com/psavelis/team-pro/replay-api/pkg/app/cs/state"
        common "github.com/psavelis/team-pro/replay-api/pkg/domain"
        cs_entity "github.com/psavelis/team-pro/replay-api/pkg/domain/cs/entities"
        replay_entity "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/entities"
)

func BeginNewMatch(ctx context.Context, p dem.Parser, matchContext *state.CS2MatchContext, out chan *replay_entity.GameEvent) func(e evt.MatchStart) <span class="cov0" title="0">{
        return func(event evt.MatchStart) </span><span class="cov0" title="0">{
                h := p.Header()

                matchContext.SetHeader(cs_entity.CSReplayFileHeader{
                        Filestamp:       h.Filestamp,
                        Protocol:        h.Protocol,
                        NetworkProtocol: h.NetworkProtocol,
                        ServerName:      h.ServerName,
                        ClientName:      h.ClientName,
                        MapName:         h.MapName,
                        Length:          h.PlaybackTime,
                        Ticks:           h.PlaybackTicks,
                        Frames:          h.PlaybackFrames,
                })

                b := builders.NewCSMatchStatsBuilder(p, matchContext).WithRoundsStats(matchContext.RoundContexts)

                out &lt;- &amp;replay_entity.GameEvent{
                        ID:            uuid.New(),
                        GameID:        common.CS2.ID,
                        MatchID:       matchContext.MatchID,
                        Type:          common.CS2.InGameEvents[common.Event_MatchStartID],
                        Time:          p.CurrentTime(),
                        EventData:     b.BuildWithHeader(),
                        ResourceOwner: matchContext.ResourceOwner,
                }
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package handlers

import (
        "github.com/google/uuid"
        dem "github.com/markus-wa/demoinfocs-golang/v4/pkg/demoinfocs"
        csinfo "github.com/markus-wa/demoinfocs-golang/v4/pkg/demoinfocs/common"
        evt "github.com/markus-wa/demoinfocs-golang/v4/pkg/demoinfocs/events"
        "github.com/psavelis/team-pro/replay-api/pkg/app/cs/builders"
        "github.com/psavelis/team-pro/replay-api/pkg/app/cs/state"
        common "github.com/psavelis/team-pro/replay-api/pkg/domain"
        csDomain "github.com/psavelis/team-pro/replay-api/pkg/domain/cs/entities"
        e "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/entities"
)

func ClutchEnd(p dem.Parser, matchContext *state.CS2MatchContext, out chan e.GameEvent) func(e evt.RoundEnd) error <span class="cov0" title="0">{
        return func(event evt.RoundEnd) error </span><span class="cov0" title="0">{
                roundIndex := p.GameState().TotalRoundsPlayed() - 1

                if !matchContext.InClutch(roundIndex) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">playerInClutch := *matchContext.GetClutchPlayer(roundIndex)

                isWinner := event.Winner == playerInClutch.Team

                var opponentsState []*csinfo.Player
                var result csDomain.ClutchSituationStatusKey

                if isWinner </span><span class="cov0" title="0">{
                        result = csDomain.ClutchWonKey
                        opponentsState = event.LoserState.Members()
                }</span> else<span class="cov0" title="0"> {
                        result = csDomain.ClutchLostKey
                        opponentsState = event.WinnerState.Members()
                }</span>

                <span class="cov0" title="0">remainingOpponents := make([]csinfo.Player, len(opponentsState))
                for k, player := range opponentsState </span><span class="cov0" title="0">{
                        remainingOpponents[k] = *player
                }</span>

                <span class="cov0" title="0">matchContext = matchContext.UpdateClutch(roundIndex, result, remainingOpponents)

                b := builders.NewCSMatchStatsBuilder(p, matchContext).WithRoundsStats(matchContext.RoundContexts)

                out &lt;- e.GameEvent{
                        ID:              uuid.New(),
                        MatchID:         matchContext.MatchID,
                        Type:            common.CS2.InGameEvents["ClutchEnd"],
                        Time:            p.CurrentTime(),
                        EventData:       b.Build(),
                        PlayerStats:     b.StatsFromPlayer(roundIndex, playerInClutch),
                        NetworkPlayerID: playerInClutch.SteamID64,
                        PlayerName:      playerInClutch.Name,
                        ResourceOwner:   matchContext.ResourceOwner, // TODO: remover daqui ou do matchContext, esta redundate
                }

                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package handlers

import (
        "log/slog"

        "github.com/google/uuid"
        dem "github.com/markus-wa/demoinfocs-golang/v4/pkg/demoinfocs"
        csinfo "github.com/markus-wa/demoinfocs-golang/v4/pkg/demoinfocs/common"
        evt "github.com/markus-wa/demoinfocs-golang/v4/pkg/demoinfocs/events"
        "github.com/psavelis/team-pro/replay-api/pkg/app/cs/builders"
        "github.com/psavelis/team-pro/replay-api/pkg/app/cs/state"
        common "github.com/psavelis/team-pro/replay-api/pkg/domain"
        csDomain "github.com/psavelis/team-pro/replay-api/pkg/domain/cs/entities"
        e "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/entities"
)

func ClutchProgress(p dem.Parser, matchContext *state.CS2MatchContext, out chan e.GameEvent) func(e evt.Kill) <span class="cov0" title="0">{
        return func(event evt.Kill) </span><span class="cov0" title="0">{
                roundIndex := p.GameState().TotalRoundsPlayed() - 1

                if !matchContext.InClutch(roundIndex) </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">if event.Killer == nil </span><span class="cov0" title="0">{
                        // msg := fmt.Sprintf("Killer is nil, evt %v", event)
                        // slog.Debug(msg)
                        // panic(msg)

                        // TODO: criar handler pra quando cair para o pacote
                        return
                }</span>

                <span class="cov0" title="0">playerInClutch := *matchContext.GetClutchPlayer(roundIndex)

                fragger := *event.Killer

                isClutchPlayer := fragger.SteamID64 == playerInClutch.SteamID64
                isNotSelf := fragger.SteamID64 != (*event.Opponent).SteamID64
                isNotFriendlyFire := event.Killer.GetTeam() != event.Opponent.GetTeam()

                isProgress := isClutchPlayer &amp;&amp; isNotSelf &amp;&amp; isNotFriendlyFire
                if !isProgress </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">var opponents []csinfo.Player

                for _, player := range p.GameState().Participants().Playing() </span><span class="cov0" title="0">{
                        if !player.IsAlive() </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if player.Team != playerInClutch.Team </span><span class="cov0" title="0">{
                                opponents = append(opponents, *player)
                        }</span>
                }

                <span class="cov0" title="0">matchContext = matchContext.UpdateClutch(roundIndex, csDomain.ClutchProgressKey, opponents)

                b := builders.NewCSMatchStatsBuilder(p, matchContext).WithRoundsStats(matchContext.RoundContexts)

                slog.Info("ClutchProgress event: %v", "event", event)

                out &lt;- e.GameEvent{
                        ID:              uuid.New(),
                        MatchID:         matchContext.MatchID,
                        Type:            common.CS2.InGameEvents["ClutchProgress"],
                        Time:            p.CurrentTime(),
                        EventData:       b.Build(),
                        PlayerStats:     b.StatsFromPlayer(roundIndex, playerInClutch),
                        NetworkPlayerID: playerInClutch.SteamID64,
                        PlayerName:      playerInClutch.Name,
                        ResourceOwner:   matchContext.ResourceOwner,
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package handlers

import (
        "fmt"
        "log/slog"

        "github.com/google/uuid"
        dem "github.com/markus-wa/demoinfocs-golang/v4/pkg/demoinfocs"
        infocs "github.com/markus-wa/demoinfocs-golang/v4/pkg/demoinfocs/common"
        evt "github.com/markus-wa/demoinfocs-golang/v4/pkg/demoinfocs/events"
        "github.com/psavelis/team-pro/replay-api/pkg/app/cs/builders"
        "github.com/psavelis/team-pro/replay-api/pkg/app/cs/state"
        common "github.com/psavelis/team-pro/replay-api/pkg/domain"
        e "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/entities"
)

func ClutchStart(p dem.Parser, matchContext *state.CS2MatchContext, out chan e.GameEvent) func(e evt.Kill) <span class="cov0" title="0">{
        return func(event evt.Kill) </span><span class="cov0" title="0">{
                ct := make([]infocs.Player, 0)
                t := make([]infocs.Player, 0)

                gs := p.GameState()

                if gs == nil </span><span class="cov0" title="0">{
                        msg := "Game state is nil"
                        slog.Debug(msg)
                        panic(msg)</span>
                        // return
                }

                <span class="cov0" title="0">roundIndex := gs.TotalRoundsPlayed()

                matchContext = matchContext.WithRound(roundIndex)

                if matchContext.InClutch(roundIndex) </span><span class="cov0" title="0">{
                        msg := fmt.Sprintf("Already in clutch situation, round index: %d", roundIndex)
                        slog.Debug(msg)
                        return
                }</span>

                <span class="cov0" title="0">for _, player := range p.GameState().Participants().Playing() </span><span class="cov0" title="0">{
                        if !player.IsAlive() </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if player.Team == infocs.TeamCounterTerrorists </span><span class="cov0" title="0">{
                                ct = append(ct, *player)
                        }</span> else<span class="cov0" title="0"> {
                                t = append(t, *player)
                        }</span>
                }

                <span class="cov0" title="0">var playerInClutch *infocs.Player
                var opponents []infocs.Player

                if len(ct) == 1 </span><span class="cov0" title="0">{
                        playerInClutch = &amp;ct[0]
                        opponents = t
                }</span>

                <span class="cov0" title="0">if len(t) == 1 </span><span class="cov0" title="0">{
                        playerInClutch = &amp;t[0]
                        opponents = ct
                }</span>

                <span class="cov0" title="0">if playerInClutch == nil </span><span class="cov0" title="0">{
                        msg := fmt.Sprintf("Not in clutch situation, ct players: %d, t players: %d", len(ct), len(t))
                        slog.Debug(msg)
                        // panic(err)
                        return
                }</span>

                <span class="cov0" title="0">roundContext := matchContext.WithClutch(roundIndex, playerInClutch, opponents)

                b := builders.NewCSMatchStatsBuilder(p, matchContext).WithRoundsStats(matchContext.RoundContexts)

                player := *roundContext.GetClutch().GetPlayer()

                out &lt;- e.GameEvent{
                        ID:              uuid.New(),
                        MatchID:         matchContext.MatchID,
                        Type:            common.CS2.InGameEvents["ClutchStart"],
                        Time:            p.CurrentTime(),
                        EventData:       b.Build(),
                        PlayerStats:     b.StatsFromPlayer(roundIndex, player),
                        NetworkPlayerID: player.SteamID64,
                        PlayerName:      player.Name,
                        ResourceOwner:   matchContext.ResourceOwner,
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package handlers

import (
        "fmt"
        "log/slog"

        "github.com/google/uuid"
        dem "github.com/markus-wa/demoinfocs-golang/v4/pkg/demoinfocs"
        evt "github.com/markus-wa/demoinfocs-golang/v4/pkg/demoinfocs/events"
        state "github.com/psavelis/team-pro/replay-api/pkg/app/cs/state"
        common "github.com/psavelis/team-pro/replay-api/pkg/domain"
        "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/entities"
)

func MatchStart(p dem.Parser, matchContext state.CS2MatchContext, out chan entities.GameEvent) func(e evt.MatchStart) <span class="cov0" title="0">{
        return func(event evt.MatchStart) </span><span class="cov0" title="0">{
                slog.Info(fmt.Sprintf("%s event", common.Event_MatchStartID), "event", event)
                out &lt;- entities.GameEvent{
                        ID:            uuid.New(),
                        GameID:        common.CS2.ID,
                        MatchID:       matchContext.MatchID,
                        Type:          common.CS2.InGameEvents[common.Event_MatchStartID],
                        Time:          p.CurrentTime(),
                        EventData:     event,
                        ResourceOwner: matchContext.ResourceOwner,
                }
        }</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package handlers

import (
        "github.com/google/uuid"
        dem "github.com/markus-wa/demoinfocs-golang/v4/pkg/demoinfocs"
        evt "github.com/markus-wa/demoinfocs-golang/v4/pkg/demoinfocs/events"
        "github.com/psavelis/team-pro/replay-api/pkg/app/cs/state"
        common "github.com/psavelis/team-pro/replay-api/pkg/domain"
        "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/entities"
)

func GenericGameEvent(p dem.Parser, matchContext state.CS2MatchContext, out chan entities.GameEvent) func(e evt.GenericGameEvent) <span class="cov0" title="0">{
        return func(event evt.GenericGameEvent) </span><span class="cov0" title="0">{
                // slog.Info("GenericGameEvent: %v", event.Name, event.Data)

                out &lt;- entities.GameEvent{
                        ID:            uuid.New(),
                        MatchID:       matchContext.MatchID,
                        Type:          common.CS2.InGameEvents["GenericGameEvent"],
                        Time:          p.CurrentTime(),
                        EventData:     event.Data,
                        ResourceOwner: matchContext.ResourceOwner,
                }
        }</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package handlers

import (
        "log/slog"

        "github.com/google/uuid"
        dem "github.com/markus-wa/demoinfocs-golang/v4/pkg/demoinfocs"
        evt "github.com/markus-wa/demoinfocs-golang/v4/pkg/demoinfocs/events"
        state "github.com/psavelis/team-pro/replay-api/pkg/app/cs/state"
        common "github.com/psavelis/team-pro/replay-api/pkg/domain"
        "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/entities"
)

func RoundMVP(p dem.Parser, matchContext state.CS2MatchContext, out chan entities.GameEvent) func(e evt.RoundMVPAnnouncement) <span class="cov0" title="0">{
        return func(event evt.RoundMVPAnnouncement) </span><span class="cov0" title="0">{
                slog.Info("RoundMVP event: %v", "event", event)

                out &lt;- entities.GameEvent{
                        ID:            uuid.New(),
                        MatchID:       matchContext.MatchID,
                        Type:          common.CS2.InGameEvents["RoundMVPAnnouncement"],
                        Time:          p.CurrentTime(),
                        EventData:     event,
                        ResourceOwner: matchContext.ResourceOwner,
                }
        }</span>
}

// ID        uuid.UUID     `json:"id"`
//         MatchID   string        `json:"match_id"`
//         Type      string        `json:"type"`
//         Time      time.Duration `json:"event_time"`
//         EventData interface{}   `json:"event_data"`
</pre>
		
		<pre class="file" id="file21" style="display: none">package cs2

import (
        "context"
        "io"
        "log/slog"

        "github.com/google/uuid"
        dem "github.com/markus-wa/demoinfocs-golang/v4/pkg/demoinfocs"
        handlers "github.com/psavelis/team-pro/replay-api/pkg/app/cs/handlers"
        state "github.com/psavelis/team-pro/replay-api/pkg/app/cs/state"
        e "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/entities"
)

type CS2ReplayAdapter struct {
}

func NewCS2ReplayAdapter() *CS2ReplayAdapter <span class="cov8" title="1">{
        return &amp;CS2ReplayAdapter{}
}</span>

func registerParsers(p dem.Parser, matchContext *state.CS2MatchContext, eventsChan chan e.GameEvent) <span class="cov8" title="1">{
        p.RegisterEventHandler(handlers.MatchStart(p, *matchContext, eventsChan))
        p.RegisterEventHandler(handlers.RoundMVP(p, *matchContext, eventsChan))
        p.RegisterEventHandler(handlers.ClutchStart(p, matchContext, eventsChan))
        p.RegisterEventHandler(handlers.ClutchProgress(p, matchContext, eventsChan))
        p.RegisterEventHandler(handlers.ClutchEnd(p, matchContext, eventsChan))
        p.RegisterEventHandler(handlers.GenericGameEvent(p, *matchContext, eventsChan))
}</span>

func (c *CS2ReplayAdapter) Parse(ctx context.Context, matchID uuid.UUID, content io.Reader, eventsChan chan e.GameEvent) error <span class="cov8" title="1">{
        matchContext := state.NewCS2MatchContext(ctx, matchID)
        parser := dem.NewParser(content)
        slog.Info("Parsing demo file at %s", "CS2ReplayAdapter.GetEvents", matchID)
        defer parser.Close()

        registerParsers(parser, matchContext, eventsChan)

        err := parser.ParseToEnd()

        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "Failed to parse demo: %v", err)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package state

import (
        cs2 "github.com/markus-wa/demoinfocs-golang/v4/pkg/demoinfocs/common"
        e "github.com/psavelis/team-pro/replay-api/pkg/domain/cs/entities"
)

type CS2ClutchContext struct {
        RoundNumber int
        Player      *cs2.Player
        Opponents   []cs2.Player
        Status      e.ClutchSituationStatusKey
}

func (c *CS2ClutchContext) GetRoundNumber() int <span class="cov0" title="0">{
        return c.RoundNumber
}</span>

func (c *CS2ClutchContext) GetPlayer() *cs2.Player <span class="cov9" title="939">{
        return c.Player
}</span>

func (c *CS2ClutchContext) GetNetworkPlayerID() uint64 <span class="cov9" title="895">{
        return (*c.Player).SteamID64
}</span>

func (c *CS2ClutchContext) GetOpponents() []cs2.Player <span class="cov10" title="1790">{
        return c.Opponents
}</span>

func (c *CS2ClutchContext) SetPlayer(player *cs2.Player) <span class="cov0" title="0">{
        c.Player = player
}</span>

func (c *CS2ClutchContext) SetOpponents(opponents []cs2.Player) <span class="cov0" title="0">{
        c.Opponents = opponents
}</span>

func (c *CS2ClutchContext) SetStatus(status e.ClutchSituationStatusKey) <span class="cov0" title="0">{
        c.Status = status
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package state

import (
        "context"

        "github.com/google/uuid"
        infocs "github.com/markus-wa/demoinfocs-golang/v4/pkg/demoinfocs/common"
        common "github.com/psavelis/team-pro/replay-api/pkg/domain"
        cs_entity "github.com/psavelis/team-pro/replay-api/pkg/domain/cs/entities"
)

type CS2MatchContext struct {
        MatchID        uuid.UUID `json:"match_id"`
        Header         cs_entity.CSReplayFileHeader
        RoundContexts map[int]CS2RoundContext `json:"round_contexts"`
        ResourceOwner  common.ResourceOwner    `json:"resource_owner"`
}

func NewCS2MatchContext(userContext context.Context, matchID uuid.UUID) *CS2MatchContext <span class="cov1" title="1">{
        return &amp;CS2MatchContext{
                MatchID:        matchID,
                RoundContexts: make(map[int]CS2RoundContext),
                ResourceOwner:  common.GetResourceOwner(userContext),
        }
}</span>

func (m *CS2MatchContext) AddRoundContext(roundID int, roundContext CS2RoundContext) <span class="cov5" title="25">{
        m.RoundContexts[roundID] = roundContext
}</span>

func (m *CS2MatchContext) WithRound(roundIndex int) *CS2MatchContext <span class="cov8" title="177">{
        _, ok := m.RoundContexts[roundIndex]
        if ok </span><span class="cov8" title="152">{
                return m
        }</span>

        <span class="cov5" title="25">roundNumber := roundIndex + 1

        roundContext := CS2RoundContext{
                RoundNumber:         roundNumber,
                WinnerNetworkTeamID: "",
                Clutch: &amp;CS2ClutchContext{
                        RoundNumber: roundNumber,
                        Status:      cs_entity.NotInClutchSituation,
                },
        }

        m.AddRoundContext(roundIndex, roundContext)

        return m</span>
}

func (m *CS2MatchContext) SetHeader(h cs_entity.CSReplayFileHeader) <span class="cov0" title="0">{
        m.Header = h
}</span>

func (m *CS2MatchContext) SetClutchRoundContext(roundIndex int, clutchStatus cs_entity.ClutchSituationStatusKey) <span class="cov0" title="0">{
        roundContext, ok := m.RoundContexts[roundIndex]

        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">roundContext.Clutch.Status = clutchStatus</span>
}

func (m *CS2MatchContext) WithClutch(roundIndex int, playerInClutch *infocs.Player, opponents []infocs.Player) CS2RoundContext <span class="cov5" title="24">{
        roundContext, ok := m.RoundContexts[roundIndex]
        roundNumber := roundIndex + 1

        if !ok </span><span class="cov0" title="0">{
                m.AddRoundContext(roundIndex, CS2RoundContext{
                        Clutch: &amp;CS2ClutchContext{
                                RoundNumber: roundNumber,
                                Status:      cs_entity.ClutchInitiatedKey,
                                Player:      playerInClutch,
                                Opponents:   opponents,
                        },
                        RoundNumber: roundNumber,
                })

                return roundContext
        }</span>

        <span class="cov5" title="24">if roundContext.Clutch.Status == cs_entity.NotInClutchSituation </span><span class="cov5" title="24">{
                roundContext.Clutch.Status = cs_entity.ClutchInitiatedKey
                roundContext.Clutch.Player = playerInClutch
                roundContext.Clutch.Opponents = opponents
                roundContext.Clutch.RoundNumber = roundNumber
        }</span>

        <span class="cov5" title="24">return roundContext</span>
}

func (m *CS2MatchContext) GetClutchPlayer(roundIndex int) *infocs.Player <span class="cov8" title="194">{
        return m.RoundContexts[roundIndex].Clutch.Player
}</span>

func (m *CS2MatchContext) GetClutchRoundContext(roundIndex int) CS2RoundContext <span class="cov0" title="0">{
        return m.RoundContexts[roundIndex]
}</span>

func (m *CS2MatchContext) UpdateClutch(roundIndex int, clutchStatus cs_entity.ClutchSituationStatusKey, opponents []infocs.Player) *CS2MatchContext <span class="cov6" title="49">{
        roundContext, ok := m.RoundContexts[roundIndex]

        if !ok </span><span class="cov0" title="0">{
                msg := "Round context not found to UpdateClutch"
                panic(msg)</span>
                // return m
        }

        <span class="cov6" title="49">roundContext.Clutch.Status = clutchStatus

        return m</span>
}

func (m *CS2MatchContext) InClutch(roundIndex int) bool <span class="cov10" title="378">{
        roundContext, ok := m.RoundContexts[roundIndex]

        if !ok </span><span class="cov3" title="6">{
                return false
        }</span>

        <span class="cov9" title="372">return roundContext.Clutch.Status != cs_entity.NotInClutchSituation</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package state

type CS2RoundContext struct {
        RoundNumber         int
        WinnerNetworkTeamID string // TODO: ver qual campo identifica o time!
        Clutch              *CS2ClutchContext
}

func (r *CS2RoundContext) GetRoundNumber() int <span class="cov0" title="0">{
        return r.RoundNumber
}</span>

func (r *CS2RoundContext) GetWinnerNetworkTeamID() string <span class="cov0" title="0">{
        return r.WinnerNetworkTeamID
}</span>

func (r *CS2RoundContext) GetClutch() *CS2ClutchContext <span class="cov10" title="2729">{
        return r.Clutch
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package common

import (
        "context"
        "fmt"
        "reflect"
)

type BaseQueryService[T any] struct {
        Reader          Searchable[T]
        QueryableFields map[string]bool
        ReadableFields  map[string]bool
        MaxPageSize     uint
        Audience        IntendedAudienceKey
        name            string
}

func (service *BaseQueryService[T]) GetName() string <span class="cov0" title="0">{
        if service.name != "" </span><span class="cov0" title="0">{
                return service.name
        }</span>

        <span class="cov0" title="0">service.name = reflect.TypeOf(service).Name()

        return service.name</span>
}

func (service *BaseQueryService[T]) Search(ctx context.Context, s Search) ([]T, error) <span class="cov0" title="0">{
        gameEvents, err := service.Reader.Search(ctx, s)

        if err != nil </span><span class="cov0" title="0">{
                var typeDef T
                typeName := reflect.TypeOf(typeDef).Name()
                svcName := service.GetName()
                return nil, fmt.Errorf("error filtering. Service: %v. Entity: %v. Error: %v", svcName, typeName, err)
        }</span>

        <span class="cov0" title="0">return gameEvents, nil</span>
}

func (svc *BaseQueryService[T]) Compile(ctx context.Context, searchParams []SearchAggregation, resultOptions SearchResultOptions) (*Search, error) <span class="cov0" title="0">{
        err := ValidateSearchParameters(searchParams, svc.QueryableFields)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error validating search parameters: %v", err)
        }</span>

        <span class="cov0" title="0">err = ValidateResultOptions(resultOptions, svc.ReadableFields)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error validating result options: %v", err)
        }</span>

        <span class="cov0" title="0">s := NewSearchByAggregation(ctx, searchParams, resultOptions, svc.Audience)

        return &amp;s, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package entities

import (
        "github.com/google/uuid"
        common "github.com/psavelis/team-pro/replay-api/pkg/domain"
)

type CSMatchStats struct {
        MatchID       uuid.UUID            `json:"match_id" bson:"match_id"`
        GameState     CSGameState          `json:"game_state" bson:"game_state"`
        Rules         CSGameRules          `json:"rules" bson:"rules"`
        RoundsStats   []CSRoundStats       `json:"rounds_stats"`
        ResourceOwner common.ResourceOwner `json:"resource_owner"`
        Header        *CSReplayFileHeader  `json:"replay_file_header" bson:"replay_file_header"`
}

func NewCSMatchStats(matchID uuid.UUID, resourceOwner common.ResourceOwner, roundCount int) CSMatchStats <span class="cov10" title="73">{
        return CSMatchStats{
                MatchID:       matchID,
                RoundsStats:   make([]CSRoundStats, roundCount),
                ResourceOwner: resourceOwner,
        }
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package entities

import (
        "github.com/golang/geo/r3"
        "github.com/google/uuid"
)

type CSPlayerStats struct {
        NetworkPlayerID string     `json:"network_player_id" bson:"network_player_id"` // (SteamID64) ID is the unique identifier of the player scoreboard
        PlayerID        *uuid.UUID `json:"player" bson:"player"`                       // PlayerID is the Domain ID of the player
        Health          int        `json:"health" bson:"health"`
        Armor           int        `json:"armor" bson:"armor"`
        // Inventory          []dto.Weapon `json:"inventory" bson:"inventory"` // Inventory is the list of weapons a player has
        Money              int       `json:"money" bson:"money"`
        Kills              int       `json:"kills" bson:"kills"`                                 // Kills is the number of times a player kills an enemy
        Deaths             int       `json:"deaths" bson:"deaths"`                               // Deaths is the number of times a player is killed
        Assists            int       `json:"assists" bson:"assists"`                             // Assists is the number of kills a player gets when they damage an enemy and a teammate finishes them off
        Headshots          int       `json:"headshots" bson:"headshots"`                         // Headshots is the number of kills a player gets by shooting an enemy in the head
        TotalRoundsPlayed  int       `json:"total_rounds_played" bson:"total_rounds_played"`     // TotalRoundsPlayed is the total number of rounds a player has played
        TotalDamage        int       `json:"total_damage" bson:"total_damage"`                   // TotalDamage is the total damage a player has done to enemies
        ADR                float64   `json:"adr" bson:"adr,truncate"`                            // ADR is the average damage per round
        LastAlivePosition  r3.Vector `json:"last_alive_position" bson:"last_alive_position"`     // LastAlivePosition is the position where the player was last alive
        KAST               int       `json:"kast" bson:"kast"`                                   // KAST is a percentage of rounds in which a player either had a kill, assist, survived or was traded
        EntryFrags         int       `json:"entry_frags" bson:"entry_frags"`                     // EntryFrags is the number of kills a player gets when they are the first to kill an enemy
        TradeFrags         int       `json:"trade_frags" bson:"trade_frags"`                     // TradeFrags is the number of kills a player gets when they are the second to kill an enemy
        FirstKills         int       `json:"first_kills" bson:"first_kills"`                     // FirstKills is the number of times a player gets the first kill in a round
        Clutches           int       `json:"clutches" bson:"clutches"`                           // Clutches is the number of times a player wins a round when they are the last player alive
        Flashes            int       `json:"flashes" bson:"flashes"`                             // Flashes is the number of times a player flashes an enemy
        DeathsToKillsRatio float64   `json:"deaths_to_kills_ratio" bson:"deaths_to_kills_ratio"` // DeathsToKillsRatio is the ratio of deaths to kills
}

func CalculateADR(totalDamage int, roundsPlayed int) float64 <span class="cov10" title="13017">{
        if roundsPlayed &lt;= 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov10" title="13017">return float64(totalDamage) / float64(roundsPlayed)</span>
}

func CalculateKDR(d, k int) float64 <span class="cov10" title="13017">{
        if k == 0 </span><span class="cov7" title="1009">{
                return 0.0
        }</span>

        <span class="cov9" title="12008">return float64(d) / float64(k)</span>
}

func CalculateKAST(kills, assists, survived, traded int, roundsPlayed int) int <span class="cov0" title="0">{
        if roundsPlayed &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return (kills + assists + survived + traded) / roundsPlayed</span>
}

// type Player struct {
//         demoInfoProvider demoInfoProvider // provider for demo info such as tick-rate or current tick

//         SteamID64             uint64             // 64-bit representation of the user's Steam ID. See https://developer.valvesoftware.com/wiki/SteamID
//         LastAlivePosition     r3.Vector          // The location where the player was last alive. Should be equal to Position if the player is still alive.
//         UserID                int                // Mostly used in game-events to address this player
//         Name                  string             // Steam / in-game user name
//         Inventory             map[int]*Equipment // All weapons / equipment the player is currently carrying. See also Weapons().
//         AmmoLeft              [32]int            // Ammo left for special weapons (e.g. grenades), index corresponds Equipment.AmmoType
//         EntityID              int                // Usually the same as Entity.ID() but may be different between player death and re-spawn.
//         Entity                st.Entity          // May be nil between player-death and re-spawn
//         FlashDuration         float32            // Blindness duration from the flashbang currently affecting the player (seconds)
//         FlashTick             int                // In-game tick at which the player was last flashed
//         TeamState             *TeamState         // When keeping the reference make sure you notice when the player changes teams
//         Team                  Team               // Team identifier for the player (e.g. TeamTerrorists or TeamCounterTerrorists).
//         IsBot                 bool               // True if this is a bot-entity. See also IsControllingBot and ControlledBot().
//         IsConnected           bool
//         IsDefusing            bool
//         IsPlanting            bool
//         IsReloading           bool
//         IsUnknown             bool      // Used to identify unknown/broken players. see https://github.com/markus-wa/demoinfocs-golang/issues/162
//         PreviousFramePosition r3.Vector // CS2 only, used to compute velocity as it's not networked in CS2 demos
// }
</pre>
		
		<pre class="file" id="file28" style="display: none">package common

import (
        "time"

        "github.com/google/uuid"
)

type BaseEntity struct {
        ID            uuid.UUID     `json:"id" bson:"_id"`
        ResourceOwner ResourceOwner `json:"resource_owner" bson:"resource_owner"`
        CreatedAt     time.Time     `json:"created_at" bson:"created_at"`
        UpdatedAt     time.Time     `json:"updated_at" bson:"updated_at"`
}

type Entity interface {
        GetID() uuid.UUID
}

func (b BaseEntity) GetID() uuid.UUID <span class="cov0" title="0">{
        return b.ID
}</span>

func NewEntity(resourceOwner ResourceOwner) BaseEntity <span class="cov0" title="0">{
        return BaseEntity{
                ID:            uuid.New(),
                ResourceOwner: resourceOwner,
                CreatedAt:     time.Now(),
                UpdatedAt:     time.Now(),
        }
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package common

type GameIDKey string

const (
        CS2_GAME_ID   GameIDKey = "cs2"
        CSGO_GAME_ID  GameIDKey = "csgo"
        VLRNT_GAME_ID GameIDKey = "vlrnt"
)

type EventIDKey string

const (
        Event_MatchStartID           EventIDKey = "MatchStart"
        Event_RoundMVPAnnouncementID EventIDKey = "RoundMVPAnnouncement"
        Event_GenericGameEventID     EventIDKey = "GenericGameEvent"
        Event_ClutchStartID          EventIDKey = "ClutchStart"
        Event_ClutchProgressID       EventIDKey = "ClutchProgress"
        Event_ClutchEndID            EventIDKey = "ClutchEnd"
)

type Game struct {
        ID           GameIDKey             `json:"id"`             // ID is the unique identifier of the game.
        Name         string                `json:"name"`           // Name is the name of the game.
        InGameEvents map[EventIDKey]string `json:"in_game_events"` // InGameEvents is a map of SUPPORTED/IMPLEMENTED in-game events to their corresponding event names.
}

func mapCSEvents() map[EventIDKey]string <span class="cov10" title="2">{
        events := make(map[EventIDKey]string, 0)

        events[Event_MatchStartID] = "begin_new_match"
        events[Event_RoundMVPAnnouncementID] = "round_mvp"
        events[Event_GenericGameEventID] = "generic_game_event"
        events[Event_ClutchStartID] = "custom::clutch_start"
        events[Event_ClutchProgressID] = "custom::clutch_progress"
        events[Event_ClutchEndID] = "custom::clutch_end"

        return events
}</span>

func mapVlrntEvents() map[EventIDKey]string <span class="cov1" title="1">{
        events := make(map[EventIDKey]string, 0)

        events[Event_GenericGameEventID] = "vlrnt::generic_game_event"
        events[Event_MatchStartID] = "vlrnt::new_match"

        return events
}</span>

var (
        CS2 = &amp;Game{
                ID:           CS2_GAME_ID,
                Name:         "Counter-Strike: 2",
                InGameEvents: mapCSEvents(),
        }

        CSGO = &amp;Game{
                ID:           CSGO_GAME_ID,
                Name:         "Counter-Strike: Global Offensive",
                InGameEvents: mapCSEvents(),
        }

        VLRNT = &amp;Game{
                ID:           VLRNT_GAME_ID,
                Name:         "Valorant",
                InGameEvents: mapVlrntEvents(),
        }
)
</pre>
		
		<pre class="file" id="file30" style="display: none">package entities

import (
        "time"

        "github.com/google/uuid"
        common "github.com/psavelis/team-pro/replay-api/pkg/domain"
)

type RIDSourceKey string

const (
        RIDSource_Steam  RIDSourceKey = "steam"
        RIDSource_Google RIDSourceKey = "google"
)

type RIDToken struct {
        ID            uuid.UUID            `json:"-" bson:"_id"`
        Key           uuid.UUID            `json:"-" bson:"key"`
        Source        RIDSourceKey         `json:"-" bson:"source"`
        ResourceOwner common.ResourceOwner `json:"-" bson:"resource_owner"`
        ExpiresAt     time.Time            `json:"-" bson:"expires_at"`
        CreatedAt     time.Time            `json:"-" bson:"created_at"`
        UpdatedAt     time.Time            `json:"-" bson:"updated_at"`
}

func (t RIDToken) GetID() uuid.UUID <span class="cov0" title="0">{
        return t.ID
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package use_cases

import (
        "context"
        "log/slog"
        "time"

        "github.com/google/uuid"
        common "github.com/psavelis/team-pro/replay-api/pkg/domain"
        iam_entity "github.com/psavelis/team-pro/replay-api/pkg/domain/iam/entities"
        iam_in "github.com/psavelis/team-pro/replay-api/pkg/domain/iam/ports/in"
        iam_out "github.com/psavelis/team-pro/replay-api/pkg/domain/iam/ports/out"
)

type CreateRIDTokenUseCase struct {
        RIDWriter iam_out.RIDTokenWriter
        RIDReader iam_out.RIDTokenReader
}

func NewCreateRIDTokenUseCase(rIDWriter iam_out.RIDTokenWriter, rIDReader iam_out.RIDTokenReader) iam_in.CreateRIDTokenCommand <span class="cov10" title="6">{
        return &amp;CreateRIDTokenUseCase{
                RIDWriter: rIDWriter,
                RIDReader: rIDReader,
        }
}</span>

func (usecase *CreateRIDTokenUseCase) Exec(ctx context.Context, reso common.ResourceOwner, source iam_entity.RIDSourceKey) (*iam_entity.RIDToken, error) <span class="cov0" title="0">{
        duration, _ := time.ParseDuration("1h")
        expiresAt := time.Now().Add(duration)

        // TODO: verificar existencia, consistir usuario

        token, err := usecase.RIDWriter.Create(ctx, iam_entity.RIDToken{
                ID:            uuid.New(),
                Key:           uuid.New(),
                Source:        source,
                ResourceOwner: reso,
                ExpiresAt:     expiresAt,
                CreatedAt:     time.Now(),
        })

        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "unable to create rid token", "err", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return token, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package use_cases

import (
        "context"
        "fmt"
        "log/slog"
        "time"

        "github.com/google/uuid"
        common "github.com/psavelis/team-pro/replay-api/pkg/domain"
        iam_in "github.com/psavelis/team-pro/replay-api/pkg/domain/iam/ports/in"
        iam_out "github.com/psavelis/team-pro/replay-api/pkg/domain/iam/ports/out"
)

type VerifyRIDUseCase struct {
        RIDWriter iam_out.RIDTokenWriter
        RIDReader iam_out.RIDTokenReader
}

func NewVerifyRIDUseCase(rIDWriter iam_out.RIDTokenWriter, rIDReader iam_out.RIDTokenReader) iam_in.VerifyRIDKeyCommand <span class="cov10" title="6">{
        return &amp;VerifyRIDUseCase{
                RIDWriter: rIDWriter,
                RIDReader: rIDReader,
        }
}</span>

func (usecase *VerifyRIDUseCase) Exec(ctx context.Context, key uuid.UUID) (common.ResourceOwner, error) <span class="cov0" title="0">{
        s := usecase.newSearchByValidKey(ctx, key)

        tokenResult, err := usecase.RIDReader.Search(ctx, s)

        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "error getting rid token by key", "err",
                        err)

                return common.ResourceOwner{}, err
        }</span>

        <span class="cov0" title="0">if tokenResult == nil || len(tokenResult) == 0 || tokenResult[0].ID == uuid.Nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("invalid rid key")
                slog.ErrorContext(ctx, err.Error(), "key", key)

                return common.ResourceOwner{}, err
        }</span>

        <span class="cov0" title="0">if len(tokenResult) &gt; 1 </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "multiple rid tokens for the same key", "result", tokenResult, "key", key)

                // TODO: recovery: notificar conta, temp lock?, desabilitar refresh

                return common.ResourceOwner{}, fmt.Errorf("invalid RID token")
        }</span>

        <span class="cov0" title="0">return tokenResult[0].ResourceOwner, nil</span>
}

func (uc *VerifyRIDUseCase) newSearchByValidKey(ctx context.Context, key uuid.UUID) common.Search <span class="cov0" title="0">{
        notBefore := time.Now()
        params := []common.SearchAggregation{
                {
                        Params: []common.SearchParameter{
                                {
                                        ValueParams: []common.SearchableValue{
                                                {
                                                        Field: "Key",
                                                        Values: []interface{}{
                                                                key,
                                                        },
                                                },
                                        },
                                        DateParams: []common.SearchableDateRange{
                                                {
                                                        Field: "ExpiresAt",
                                                        Min:   &amp;notBefore,
                                                },
                                        },
                                },
                        },
                },
        }

        visibility := common.SearchVisibilityOptions{
                RequestSource:    common.GetResourceOwner(ctx),
                IntendedAudience: common.ClientApplicationAudienceIDKey,
        }

        result := common.SearchResultOptions{
                Skip:  0,
                Limit: 1,
        }

        return common.Search{
                SearchParams:      params,
                ResultOptions:     result,
                VisibilityOptions: visibility,
        }
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package entities

import (
        "time"

        "github.com/google/uuid"
        common "github.com/psavelis/team-pro/replay-api/pkg/domain"
)

type GameEvent struct {
        ID              uuid.UUID            `json:"id" bson:"_id"`
        GameID          common.GameIDKey     `json:"game_id" bson:"game_id"`
        MatchID         uuid.UUID            `json:"match_id" bson:"match_id"`
        Type            string               `json:"type" bson:"type"`
        Time            time.Duration        `json:"event_time" bson:"event_time"`
        EventData       interface{}          `json:"-" bson:"-"`
        PlayerStats     interface{}          `json:"player_stats" bson:"player_stats"`
        NetworkPlayerID uint64               `json:"network_player_id" bson:"network_player_id"`
        PlayerName      string               `json:"player_name" bson:"player_name"`
        ResourceOwner   common.ResourceOwner `json:"resource_owner" bson:"resource_owner"`
        CreatedAt       time.Time            `json:"created_at" bson:"created_at"`
}

func (e GameEvent) GetID() uuid.UUID <span class="cov0" title="0">{
        return e.ID
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package entities

import (
        "context"
        "time"

        "github.com/google/uuid"
        common "github.com/psavelis/team-pro/replay-api/pkg/domain"
)

type MatchVisibility string

const (
        MatchVisibilityPublic  MatchVisibility = "public"
        MatchVisibilitySquad   MatchVisibility = "squad"
        MatchVisibilityPrivate MatchVisibility = "private"
        MatchVisibilityCustom  MatchVisibility = "custom"
)

// AggregteRoot
type Match struct {
        ID            uuid.UUID            `json:"id" bson:"_id"`
        ReplayFileID  uuid.UUID            `json:"replay_file_id" bson:"replay_file_id"`
        GameID        common.GameIDKey     `json:"game_id" bson:"game_id"`
        Scoreboard    Scoreboard           `json:"scoreboard" bson:"scoreboard"`
        Events        []GameEvent          `json:"game_events" bson:"game_events"`
        Visibility    MatchVisibility      `json:"visibility" bson:"visibility"`
        ShareTokens   []ShareToken         `json:"share_tokens" bson:"share_tokens"`
        ResourceOwner common.ResourceOwner `json:"resource_owner" bson:"resource_owner"`
        CreatedAt     time.Time            `json:"created_at" bson:"created_at"`
        UpdatedAt     time.Time            `json:"updated_at" bson:"updated_at"`
}

func (m Match) GetID() uuid.UUID <span class="cov0" title="0">{
        return m.ID
}</span>

type Scoreboard struct {
        TeamScoreboards []TeamScoreboard `json:"team_scoreboards" bson:"team_scoreboards"`
        MatchMVP        *Player          `json:"match_mvp" bson:"match_mvp"`
}

type TeamScoreboard struct {
        Team        Team                      `json:"team" bson:"team"`
        TeamScore   int                       `json:"team_score" bson:"team_score"`
        TeamMVP     *Player                   `json:"team_mvp" bson:"team_mvp"`
        Players     []Player                  `json:"players" bson:"playerss"`
        PlayerStats map[uuid.UUID]interface{} `json:"player_stats" bson:"player_stats"`
        Rounds      []RoundInfo               `json:"rounds" bson:"rounds"`
        RoundStats  map[int]interface{}       `json:"round_stats" bson:"round_stats"`
}

type RoundInfo struct {
        RoundNumber      int         `json:"round_number" bson:"round_number"`
        WinnerTeamID     *uuid.UUID  `json:"winner" bson:"winner"`
        RoundMVPPlayerID *uuid.UUID  `json:"round_mvp_player_id" bson:"round_mvp_player_id"`
        Events           []GameEvent `json:"events" bson:"events"`
}

func NewCS2Match(userContext context.Context, replayFileID uuid.UUID) *Match <span class="cov0" title="0">{
        return &amp;Match{
                ID:            uuid.New(),
                ReplayFileID:  replayFileID,
                GameID:        common.CS2.ID,
                ResourceOwner: common.GetResourceOwner(userContext),
                CreatedAt:     time.Now(),
                UpdatedAt:     time.Now(),
        }
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package entities

import (
        "time"

        "github.com/google/uuid"
        common "github.com/psavelis/team-pro/replay-api/pkg/domain"
)

type Player struct {
        ID                 uuid.UUID            `json:"id" bson:"_id"`
        GameID             common.GameIDKey     `json:"game_id" bson:"game_id"`
        NetworkID          common.NetworkIDKey  `json:"network_id" bson:"network_id"`
        NetworkUserID      string               `json:"network_user_id" bson:"network_user_id"`
        UserID             *uuid.UUID           `json:"user_id" bson:"user_id"`
        CurrentName        string               `json:"current_name" bson:"current_name"`
        DisplayNameHistory []string             `json:"display_name_history" bson:"display_name_history"`
        ResourceOwner      common.ResourceOwner `json:"resource_owner" bson:"resource_owner"`
        CreatedAt          time.Time            `json:"created_at" bson:"created_at"`
        UpdatedAt          time.Time            `json:"updated_at" bson:"updated_at"`
}

func NewCS2SteamPlayer(currentName string, networkUserID string) *Player <span class="cov0" title="0">{
        return &amp;Player{
                ID:                 uuid.New(),
                GameID:             common.CS2.ID,
                NetworkID:          common.Steam.ID,
                NetworkUserID:      networkUserID,
                CurrentName:        currentName,
                DisplayNameHistory: []string{currentName},
        }
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package entities

import (
        "time"

        "github.com/google/uuid"
        common "github.com/psavelis/team-pro/replay-api/pkg/domain"
)

type ReplayFileStatus string

const (
        ReplayFileStatusPending    ReplayFileStatus = "Pending"
        ReplayFileStatusProcessing ReplayFileStatus = "Processing"
        ReplayFileStatusFailed     ReplayFileStatus = "Failed"
        ReplayFileStatusCompleted  ReplayFileStatus = "Completed"
)

func NewReplayFile(gameID common.GameIDKey, networkID common.NetworkIDKey, size int, uri string, resourceOwner common.ResourceOwner) ReplayFile <span class="cov0" title="0">{
        entity := common.NewEntity(resourceOwner)
        return ReplayFile{
                ID:            entity.ID,
                GameID:        gameID,
                NetworkID:     networkID,
                Size:          size,
                InternalURI:   uri,
                Status:        ReplayFileStatusPending,
                Error:         "",
                Header:        nil,
                ResourceOwner: resourceOwner,
                CreatedAt:     entity.CreatedAt,
                UpdatedAt:     entity.UpdatedAt,
        }
}</span>

type ReplayFile struct {
        ID            uuid.UUID            `json:"id" bson:"_id"`
        ResourceOwner common.ResourceOwner `json:"resource_owner" bson:"resource_owner"`
        CreatedAt     time.Time            `json:"created_at" bson:"created_at"`
        UpdatedAt     time.Time            `json:"updated_at" bson:"updated_at"`
        GameID        common.GameIDKey     `json:"game_id" bson:"game_id"`
        NetworkID     common.NetworkIDKey  `json:"network_id" bson:"network_id"`
        Size          int                  `json:"size" bson:"size"`
        InternalURI   string               `json:"uri" bson:"uri"`
        Status        ReplayFileStatus     `json:"status" bson:"status"`
        Error         string               `json:"error" bson:"error"`
        Header        interface{}          `json:"header" bson:"header"`
}

func (r ReplayFile) GetID() uuid.UUID <span class="cov0" title="0">{
        return r.ID
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package metadata

import (
        common "github.com/psavelis/team-pro/replay-api/pkg/domain"
        replay_entity "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/entities"
        replay_in "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/ports/in"
        replay_out "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/ports/out"
)

type EventQueryService struct {
        common.BaseQueryService[replay_entity.GameEvent]
}

func NewEventQueryService(eventReader replay_out.GameEventReader) replay_in.EventReader <span class="cov0" title="0">{
        queryableFields := map[string]bool{
                "ID":              true,
                "GameID":          true,
                "MatchID":         true,
                "Type":            true,
                "Time":            true,
                "EventData":       true,
                "PlayerStats":     common.DENY,
                "NetworkPlayerID": true,
                "PlayerName":      true,
                "ResourceOwner":   true,
                "CreatedAt":       true,
        }

        readableFields := map[string]bool{
                "ID":              true,
                "GameID":          true,
                "MatchID":         true,
                "Type":            true,
                "Time":            true,
                "EventData":       common.DENY,
                "PlayerStats":     common.DENY,
                "NetworkPlayerID": common.DENY,
                "PlayerName":      true,
                "ResourceOwner":   common.DENY,
                "CreatedAt":       true,
        }

        return &amp;common.BaseQueryService[replay_entity.GameEvent]{
                Reader:          eventReader.(common.Searchable[replay_entity.GameEvent]),
                QueryableFields: queryableFields,
                ReadableFields:  readableFields,
                MaxPageSize:     100,
                Audience:        common.UserAudienceIDKey,
        }
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package metadata

import (
        common "github.com/psavelis/team-pro/replay-api/pkg/domain"
        replay_entity "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/entities"
        replay_in "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/ports/in"
        replay_out "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/ports/out"
)

type MatchQueryService struct {
        common.BaseQueryService[replay_entity.Match]
}

func NewMatchQueryService(matchReader replay_out.MatchMetadataReader) replay_in.MatchReader <span class="cov0" title="0">{
        queryableFields := map[string]bool{
                "ID":            true,
                "GameID":        true,
                "NetworkID":     true,
                "Status":        true,
                "Error":         common.DENY,
                "Header.*":      true,
                "ResourceOwner": true,
                "CreatedAt":     true,
                "UpdatedAt":     true,
        }

        readableFields := map[string]bool{
                "ID":            true,
                "GameID":        true,
                "NetworkID":     true,
                "Status":        true,
                "Error":         common.DENY,
                "Header.*":      true,
                "ResourceOwner": true,
                "CreatedAt":     true,
                "UpdatedAt":     true,
        }

        return &amp;common.BaseQueryService[replay_entity.Match]{
                Reader:          matchReader.(common.Searchable[replay_entity.Match]),
                QueryableFields: queryableFields,
                ReadableFields:  readableFields,
                MaxPageSize:     100,
                Audience:        common.UserAudienceIDKey,
        }
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package metadata

import (
        common "github.com/psavelis/team-pro/replay-api/pkg/domain"
        replay_entity "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/entities"
        replay_in "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/ports/in"
        replay_out "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/ports/out"
)

type ReplayFileQueryService struct {
        common.BaseQueryService[replay_entity.ReplayFile]
}

func NewReplayFileQueryService(fileMetadataReader replay_out.ReplayFileMetadataReader) replay_in.ReplayFileMetadataReader <span class="cov10" title="3">{
        queryableFields := map[string]bool{
                "ID":            true,
                "GameID":        true,
                "NetworkID":     true,
                "Size":          true,
                "InternalURI":   common.DENY,
                "Status":        true,
                "Error":         common.DENY,
                "Header.*":      true,
                "ResourceOwner": true,
                "CreatedAt":     true,
                "UpdatedAt":     true,
        }

        readableFields := map[string]bool{
                "ID":            true,
                "GameID":        true,
                "NetworkID":     true,
                "Size":          true,
                "InternalURI":   common.DENY,
                "Status":        true,
                "Error":         common.DENY,
                "Header.*":      true,
                "ResourceOwner": true,
                "CreatedAt":     true,
                "UpdatedAt":     true,
        }

        return &amp;common.BaseQueryService[replay_entity.ReplayFile]{
                Reader:          fileMetadataReader.(common.Searchable[replay_entity.ReplayFile]),
                QueryableFields: queryableFields,
                ReadableFields:  readableFields,
                MaxPageSize:     100,
                Audience:        common.UserAudienceIDKey,
        }
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package use_cases

import (
        "context"
        "log/slog"

        "github.com/google/uuid"
        e "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/entities"
        replay_out "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/ports/out"
)

type ProcessReplayFileUseCase struct {
        MetadataReader replay_out.ReplayFileMetadataReader
        ContentReader  replay_out.ReplayFileContentReader
        MetadataWriter replay_out.ReplayFileMetadataWriter
        ContentWriter  replay_out.ReplayFileContentWriter
        Parser         replay_out.ReplayParser
        EventWriter    replay_out.GameEventWriter
}

func NewProcessReplayFileUseCase(metadataReader replay_out.ReplayFileMetadataReader, contentReader replay_out.ReplayFileContentReader, metadataWriter replay_out.ReplayFileMetadataWriter, contentWriter replay_out.ReplayFileContentWriter, parser replay_out.ReplayParser, eventWriter replay_out.GameEventWriter) *ProcessReplayFileUseCase <span class="cov10" title="6">{
        return &amp;ProcessReplayFileUseCase{
                MetadataReader: metadataReader,
                ContentReader:  contentReader,
                MetadataWriter: metadataWriter,
                ContentWriter:  contentWriter,
                Parser:         parser,
                EventWriter:    eventWriter,
        }
}</span>

func (usecase *ProcessReplayFileUseCase) Exec(ctx context.Context, replayFileID uuid.UUID) (*e.Match, error) <span class="cov0" title="0">{
        replayFile, err := usecase.MetadataReader.GetByID(ctx, replayFileID)
        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "error getting replay metadata", "replayFileID", replayFileID, "err", err)
                return nil, err
        }</span>

        // Update Metadata Status
        <span class="cov0" title="0">replayFile.Status = e.ReplayFileStatusProcessing
        replayFile, err = usecase.MetadataWriter.Update(ctx, *replayFile)

        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "error updating uploaded replay metadata", "replayFile", replayFile, "err", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">slog.InfoContext(ctx, "processing replay file", "replayFile", replayFile)

        match := &amp;e.Match{
                ID:            uuid.New(),
                GameID:        replayFile.GameID,
                ReplayFileID:  replayFile.ID,
                ResourceOwner: replayFile.ResourceOwner,
                Events:        make([]e.GameEvent, 0),
        }

        file, err := usecase.ContentReader.GetByID(ctx, replayFileID)
        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "error getting replay file content data", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        slog.InfoContext(ctx, "parsing replay file", "Size", replayFile.Size, "replayFileID", replayFileID)

        eventsChan := make(chan e.GameEvent, 1)
        defer close(eventsChan)

        go func() </span><span class="cov0" title="0">{
                for event := range eventsChan </span><span class="cov0" title="0">{
                        match.Events = append(match.Events, event)
                }</span>
        }()

        <span class="cov0" title="0">err = usecase.Parser.Parse(ctx, match.ID, file, eventsChan)

        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "error parsing replay events", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">err = usecase.EventWriter.CreateMany(ctx, match.Events)
        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "error saving replay events", err)
                return nil, err
        }</span>

        // Update Metadata Status
        <span class="cov0" title="0">replayFile.Status = e.ReplayFileStatusCompleted
        replayFile, err = usecase.MetadataWriter.Update(ctx, *replayFile)

        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "error updating uploaded replay metadata status to Completed", "replayFile", replayFile, "err", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return match, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package use_cases

import (
        "context"
        "log/slog"

        "github.com/google/uuid"
        common "github.com/psavelis/team-pro/replay-api/pkg/domain"
        replay_entity "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/entities"
        replay_out "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/ports/out"
)

type UpdateReplayFileHeaderUseCase struct {
        EventReader    replay_out.GameEventReader
        MetadataReader replay_out.ReplayFileMetadataReader
        MetadataWriter replay_out.ReplayFileMetadataWriter
}

func NewUpdateReplayFileHeaderUseCase(eventReader replay_out.GameEventReader,
        metadataReader replay_out.ReplayFileMetadataReader,
        metadataWriter replay_out.ReplayFileMetadataWriter) *UpdateReplayFileHeaderUseCase <span class="cov10" title="6">{
        return &amp;UpdateReplayFileHeaderUseCase{
                EventReader:    eventReader,
                MetadataReader: metadataReader,
                MetadataWriter: metadataWriter,
        }
}</span>

func (usecase *UpdateReplayFileHeaderUseCase) Exec(ctx context.Context, replayFileID uuid.UUID) (*replay_entity.ReplayFile, error) <span class="cov0" title="0">{
        file, err := usecase.MetadataReader.GetByID(ctx, replayFileID)
        if err != nil || file == nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "error updating file header: not found", "replayFileID", replayFileID, "err", err, "returnedFile", file)
                return nil, err
        }</span>

        <span class="cov0" title="0">params := []common.SearchableValue{
                {
                        Field: "Type",
                        Values: []interface{}{
                                common.Event_MatchStartID,
                        },
                },
        }

        resultOptions := common.SearchResultOptions{
                Skip:  0,
                Limit: 1,
        }

        s := common.NewSearchByValues(ctx, params, resultOptions, common.UserAudienceIDKey)

        events, err := usecase.EventReader.Search(ctx, s)

        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "error searching for replay file header event (common.Event_MatchStartID)", "err", err, "Type", common.Event_MatchStartID, "events", events)
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(events) &gt; 1 </span><span class="cov0" title="0">{
                slog.WarnContext(ctx, "replay file has more than one match", "events", events, "replayFile", file)
        }</span>

        <span class="cov0" title="0">file.Header = events[0].EventData

        file, err = usecase.MetadataWriter.Update(ctx, *file)

        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "failed to update replay file header", "err", err, "replayFile", file)
                return nil, err
        }</span>

        <span class="cov0" title="0">return file, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package use_cases

import (
        "context"
        "io"
        "log/slog"

        replay_entity "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/entities"
        replay_in "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/ports/in"
)

type UploadAndProcessReplayFileUseCase struct {
        UploadCommand       replay_in.UploadReplayFileCommand
        ProcessCommand      replay_in.ProcessReplayFileCommand
        UpdateHeaderCommand replay_in.UpdateReplayFileHeaderCommand
}

func (usecase *UploadAndProcessReplayFileUseCase) Exec(ctx context.Context, file io.Reader) (*replay_entity.Match, error) <span class="cov0" title="0">{
        replayFile, err := usecase.UploadCommand.Exec(ctx, file)
        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "error uploading replay file", "err", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">match, err := usecase.ProcessCommand.Exec(ctx, replayFile.ID)

        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "error processing replay file", "err", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err = usecase.UpdateHeaderCommand.Exec(ctx, replayFile.ID)
        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "UploadAndProcessReplayFileUseCase failed to update replay file HEADER", "err", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return match, nil</span>
}

func NewUploadAndProcessReplayFileUseCase(uploadCommand replay_in.UploadReplayFileCommand, processCommand replay_in.ProcessReplayFileCommand, updateHeaderCommand replay_in.UpdateReplayFileHeaderCommand) *UploadAndProcessReplayFileUseCase <span class="cov10" title="6">{
        return &amp;UploadAndProcessReplayFileUseCase{
                UploadCommand:       uploadCommand,
                ProcessCommand:      processCommand,
                UpdateHeaderCommand: updateHeaderCommand,
        }
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package use_cases

import (
        "bytes"
        "context"
        "io"
        "log/slog"

        common "github.com/psavelis/team-pro/replay-api/pkg/domain"
        replay_entity "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/entities"
        replay_out "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/ports/out"
)

type UploadReplayFileUseCase struct {
        MetadataWriter replay_out.ReplayFileMetadataWriter
        ContentWriter  replay_out.ReplayFileContentWriter
}

func NewUploadReplayFileUseCase(metadataWriter replay_out.ReplayFileMetadataWriter, dataCommand replay_out.ReplayFileContentWriter) *UploadReplayFileUseCase <span class="cov10" title="6">{
        return &amp;UploadReplayFileUseCase{
                MetadataWriter: metadataWriter,
                ContentWriter:  dataCommand,
        }
}</span>

func (usecase *UploadReplayFileUseCase) Exec(ctx context.Context, reader io.Reader) (*replay_entity.ReplayFile, error) <span class="cov0" title="0">{
        file, err := io.ReadAll(reader)
        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "error reading replay file", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">slog.InfoContext(ctx, "uploading replay file", "size", len(file))

        // create Metadata
        entity := replay_entity.NewReplayFile("cs", "steam", len(file), "", common.GetResourceOwner(ctx))
        replayFile, err := usecase.MetadataWriter.Create(ctx, entity)

        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "error creating new replay metadata", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">slog.InfoContext(ctx, "created new replay metadata", "replayFile", replayFile)

        // Put Contents into Blob Store
        uri, err := usecase.ContentWriter.Put(ctx, replayFile.ID, bytes.NewReader(file))
        if err != nil </span><span class="cov0" title="0">{
                replayFile.Status = replay_entity.ReplayFileStatusFailed
                replayFile.Error = err.Error()
                usecase.MetadataWriter.Update(ctx, *replayFile)
                slog.ErrorContext(ctx, "error uploading replay data", err, "replayFile", replayFile)
                return nil, err
        }</span>

        <span class="cov0" title="0">slog.InfoContext(ctx, "uploaded replay data", "replayFile", replayFile, "uri", uri)

        // Update Metadata
        replayFile.InternalURI = uri
        replayFile.Status = replay_entity.ReplayFileStatusProcessing
        replayFile, err = usecase.MetadataWriter.Update(ctx, *replayFile)

        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "error updating uploaded replay metadata", "replayFile", replayFile, "err", err)
                return nil, err
        }</span>

        // return updated metadata
        <span class="cov0" title="0">return replayFile, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package common

import (
        "context"
        "fmt"

        "github.com/google/uuid"
)

// ResourceOwner represents the owner of a resource.
type ResourceOwner struct {
        TenantID uuid.UUID `json:"tenant_id" bson:"tenant_id"` // TenantID represents the ID of the tenant the resource belongs to.
        ClientID uuid.UUID `json:"client_id" bson:"client_id"` // ClientID represents the ID of the client associated with the resource.
        GroupID  uuid.UUID `json:"group_id" bson:"group_id"`   // GroupID represents the ID of the group the resource is associated with. (redundant with ClientID ?)
        UserID   uuid.UUID `json:"user_id" bson:"user_id"`     // EndUserID represents the ID of the end user who owns the resource.
}

func GetResourceOwner(userContext context.Context) ResourceOwner <span class="cov0" title="0">{
        res := ResourceOwner{}

        if tenantID, ok := userContext.Value(TenantIDKey).(uuid.UUID); ok </span><span class="cov0" title="0">{
                res.TenantID = tenantID
        }</span>

        <span class="cov0" title="0">if clientID, ok := userContext.Value(ClientIDKey).(uuid.UUID); ok </span><span class="cov0" title="0">{
                res.ClientID = clientID
        }</span>

        <span class="cov0" title="0">if groupID, ok := userContext.Value(GroupIDKey).(uuid.UUID); ok </span><span class="cov0" title="0">{
                res.GroupID = groupID
        }</span>

        <span class="cov0" title="0">if userID, ok := userContext.Value(UserIDKey).(uuid.UUID); ok </span><span class="cov0" title="0">{
                res.UserID = userID
        }</span>

        <span class="cov0" title="0">if res.IsMissingTenant() </span><span class="cov0" title="0">{
                panic(fmt.Errorf("GetResourceOwner.IsMissingTenant: tenant_id missing in context %v", userContext))</span>
        }

        <span class="cov0" title="0">return res</span>
}

func (ro ResourceOwner) IsMissingTenant() bool <span class="cov0" title="0">{
        return ro.TenantID == uuid.Nil
}</span>

func (ro ResourceOwner) IsTenant() bool <span class="cov0" title="0">{
        return ro.TenantID != uuid.Nil &amp;&amp; ro.ClientID == uuid.Nil &amp;&amp; ro.GroupID == uuid.Nil &amp;&amp; ro.UserID == uuid.Nil
}</span>

func (ro ResourceOwner) IsClient() bool <span class="cov0" title="0">{
        return ro.TenantID != uuid.Nil &amp;&amp; ro.ClientID != uuid.Nil &amp;&amp; ro.GroupID == uuid.Nil &amp;&amp; ro.UserID == uuid.Nil
}</span>

func (ro ResourceOwner) IsGroup() bool <span class="cov0" title="0">{
        return ro.TenantID != uuid.Nil &amp;&amp; ro.GroupID != uuid.Nil &amp;&amp; ro.UserID == uuid.Nil
}</span>

func (ro ResourceOwner) IsUser() bool <span class="cov0" title="0">{
        return ro.TenantID != uuid.Nil &amp;&amp; ro.UserID != uuid.Nil
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package common

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/google/uuid"
)

type SortDirectionKey int

const (
        AscendingIDKey  SortDirectionKey = 1
        DescendingIDKey SortDirectionKey = -1
)

type SearchOperator string

const (
        EqualsOperator             SearchOperator = "eq"       // Exact match (default)
        NotEqualsOperator          SearchOperator = "ne"       // Not equal
        GreaterThanOperator        SearchOperator = "gt"       // Greater than
        LessThanOperator           SearchOperator = "lt"       // Less than
        GreaterThanOrEqualOperator SearchOperator = "gte"      // Greater than or equal
        LessThanOrEqualOperator    SearchOperator = "lte"      // Less than or equal
        ContainsOperator           SearchOperator = "contains" // Case-insensitive substring match
        StartsWithOperator         SearchOperator = "startswith"
        EndsWithOperator           SearchOperator = "endswith"
        InOperator                 SearchOperator = "in"  // Match any value in a list
        NotInOperator              SearchOperator = "nin" // Not in a list
)

const DefaultPageSize uint = 50

type IntendedAudienceKey string

const (
        TenantAudienceIDKey            IntendedAudienceKey = "TenantAudience"
        ClientApplicationAudienceIDKey IntendedAudienceKey = "ClientAudience"
        GroupAudienceIDKey             IntendedAudienceKey = "GroupAudience"
        UserAudienceIDKey              IntendedAudienceKey = "UserAudience"
)

type AggregationTypeKey string

type SearchableValue struct {
        Field    string
        Values   []interface{}
        Operator SearchOperator
}

type SearchableDateRange struct {
        Field string
        Min   *time.Time
        Max   *time.Time
}

type SearchableDurationRange struct {
        Field string
        Min   *time.Duration // opcionais
        Max   *time.Duration
}

type SortableField struct {
        Field     string
        Direction SortDirectionKey
}

type SearchParameter struct {
        ValueParams       []SearchableValue         `json:"values" bson:"value_params"`
        DateParams        []SearchableDateRange     `json:"date" bson:"date_params"`
        DurationParams    []SearchableDurationRange `json:"time" bson:"duration_params"`
        AggregationParams []SearchAggregation       `json:"aggregate" bson:"aggregation_params"`
        Operator          SearchOperator            `json:"operator" bson:"operator"` // if not provided, default to InOperator
}

type SearchAggregation struct {
        Params    []SearchParameter  `json:"params" bson:"params"`
        ParamType AggregationTypeKey `json:"type" bson:"type"`
}

type SearchResultOptions struct {
        Skip       uint     `json:"skip" bson:"skip"`        // default = 0
        Limit      uint     `json:"limit" bson:"limit"`      // default = 50
        PickFields []string `json:"pick" bson:"pick_fields"` // if not informed, pick all
        OmitFields []string `json:"omit" bson:"omit_fields"` // if not informed, doesnt omit any
}

type SearchVisibilityOptions struct {
        RequestSource    ResourceOwner       `json:"-" bson:"request_source"`
        IntendedAudience IntendedAudienceKey `json:"-" bson:"intended_audience"` // Default: User
}

type Search struct {
        SearchParams      []SearchAggregation     `json:"search_params" bson:"search_params"`
        ResultOptions     SearchResultOptions     `json:"result_options" bson:"result_options"`
        SortOptions       []SortableField         `json:"sort_options" bson:"sort_options"`
        VisibilityOptions SearchVisibilityOptions `json:"-" bson:"visibility_options"`
}

func NewSearchByID(ctx context.Context, id uuid.UUID, audienceLevel IntendedAudienceKey) Search <span class="cov0" title="0">{
        v := []SearchableValue{
                {
                        Field: "ID",
                        Values: []interface{}{
                                id,
                        },
                },
        }

        p := []SearchParameter{
                {
                        ValueParams: v,
                },
        }

        pipe := []SearchAggregation{
                {
                        Params: p,
                },
        }

        visibility := SearchVisibilityOptions{
                RequestSource:    GetResourceOwner(ctx),
                IntendedAudience: audienceLevel,
        }

        result := NewSearchResultOptions(0, 1)

        return Search{
                SearchParams:      pipe,
                ResultOptions:     result,
                VisibilityOptions: visibility,
        }
}</span>

func NewSearchResultOptions(skip uint, limit uint) SearchResultOptions <span class="cov0" title="0">{
        return SearchResultOptions{
                Skip:  skip,
                Limit: limit,
        }
}</span>

func NewSearchByAggregation(ctx context.Context, aggregationParams []SearchAggregation, resultOptions SearchResultOptions, audienceLevel IntendedAudienceKey) Search <span class="cov0" title="0">{
        visibility := SearchVisibilityOptions{
                RequestSource:    GetResourceOwner(ctx),
                IntendedAudience: audienceLevel,
        }

        if resultOptions.Limit == 0 </span><span class="cov0" title="0">{
                resultOptions.Limit = DefaultPageSize
        }</span>

        <span class="cov0" title="0">return Search{
                SearchParams:      aggregationParams,
                ResultOptions:     resultOptions,
                VisibilityOptions: visibility,
        }</span>
}

func NewSearchByValues(ctx context.Context, valueParams []SearchableValue, resultOptions SearchResultOptions, audienceLevel IntendedAudienceKey) Search <span class="cov0" title="0">{
        params := []SearchAggregation{
                {
                        Params: []SearchParameter{
                                {
                                        ValueParams: valueParams,
                                },
                        },
                },
        }

        return NewSearchByAggregation(ctx, params, resultOptions, audienceLevel)
}</span>

func NewSearchByRange(ctx context.Context, dateParams []SearchableDateRange, resultOptions SearchResultOptions, audienceLevel IntendedAudienceKey) Search <span class="cov0" title="0">{
        params := []SearchAggregation{
                {
                        Params: []SearchParameter{
                                {
                                        DateParams: dateParams,
                                },
                        },
                },
        }

        return NewSearchByAggregation(ctx, params, resultOptions, audienceLevel)
}</span>

func NewSearch(ctx context.Context, audienceLevel IntendedAudienceKey) Search <span class="cov0" title="0">{
        visibility := SearchVisibilityOptions{
                RequestSource:    GetResourceOwner(ctx),
                IntendedAudience: audienceLevel,
        }

        result := SearchResultOptions{
                Skip:  0,
                Limit: DefaultPageSize,
        }

        return Search{
                ResultOptions:     result,
                VisibilityOptions: visibility,
        }
}</span>

const (
        MaxRecursiveDepth = 10
)

func ValidateSearchParameters(searchParams []SearchAggregation, queryableFields map[string]bool) error <span class="cov10" title="12">{
        for _, param := range searchParams </span><span class="cov10" title="12">{
                for _, valueParam := range param.Params </span><span class="cov10" title="12">{
                        err := ValidateValueParams(valueParam, queryableFields)
                        if err != nil </span><span class="cov6" title="4">{
                                return err
                        }</span>
                }

                <span class="cov8" title="8">for _, dateParam := range param.Params </span><span class="cov8" title="8">{
                        err := ValidateDateParams(dateParam, queryableFields)
                        if err != nil </span><span class="cov1" title="1">{
                                return err
                        }</span>
                }

                <span class="cov8" title="7">for _, durationParam := range param.Params </span><span class="cov8" title="7">{
                        err := ValidateDurationParams(durationParam, queryableFields)
                        if err != nil </span><span class="cov3" title="2">{
                                return err
                        }</span>
                }

                <span class="cov6" title="5">for _, aggregationParam := range param.Params </span><span class="cov6" title="5">{
                        for index, aggregation := range aggregationParam.AggregationParams </span><span class="cov0" title="0">{
                                if index &gt;= MaxRecursiveDepth </span><span class="cov0" title="0">{
                                        return fmt.Errorf("maximum AggregationParams recursive depth %d reached", MaxRecursiveDepth)
                                }</span>

                                <span class="cov0" title="0">err := ValidateSearchParameters([]SearchAggregation{aggregation}, queryableFields)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }

        <span class="cov6" title="5">return nil</span>
}

func ValidateDurationParams(durationParam SearchParameter, queryableFields map[string]bool) error <span class="cov8" title="7">{
        for _, duration := range durationParam.DurationParams </span><span class="cov4" title="3">{
                field := duration.Field
                if strings.HasSuffix(field, ".*") </span><span class="cov1" title="1">{
                        prefix := strings.TrimSuffix(field, ".*")
                        allowed := false
                        for qField, allowedValue := range queryableFields </span><span class="cov1" title="1">{
                                if strings.HasPrefix(qField, prefix) &amp;&amp; allowedValue </span><span class="cov0" title="0">{
                                        allowed = true
                                        break</span>
                                }
                        }
                        <span class="cov1" title="1">if !allowed </span><span class="cov1" title="1">{
                                return fmt.Errorf("filtering on DurationParams fields matching '%s.*' is not permitted", prefix)
                        }</span>
                } else<span class="cov3" title="2"> {
                        allowed, exists := queryableFields[field]
                        if !exists || !allowed </span><span class="cov1" title="1">{
                                return fmt.Errorf("filtering on DurationParams field '%s' is not permitted", field)
                        }</span>
                }
        }
        <span class="cov6" title="5">return nil</span>
}

func ValidateDateParams(dateParam SearchParameter, queryableFields map[string]bool) error <span class="cov8" title="8">{
        for _, date := range dateParam.DateParams </span><span class="cov3" title="2">{
                field := date.Field
                if strings.HasSuffix(field, ".*") </span><span class="cov1" title="1">{
                        prefix := strings.TrimSuffix(field, ".*")
                        allowed := false
                        for qField, allowedValue := range queryableFields </span><span class="cov1" title="1">{
                                if strings.HasPrefix(qField, prefix) &amp;&amp; allowedValue </span><span class="cov0" title="0">{
                                        allowed = true
                                        break</span>
                                }
                        }
                        <span class="cov1" title="1">if !allowed </span><span class="cov1" title="1">{
                                return fmt.Errorf("filtering on DateParams fields matching '%s.*' is not permitted", prefix)
                        }</span>
                } else<span class="cov1" title="1"> {
                        allowed, exists := queryableFields[field]
                        if !exists || !allowed </span><span class="cov0" title="0">{
                                return fmt.Errorf("filtering on DateParams field '%s' is not permitted", field)
                        }</span>
                }
        }
        <span class="cov8" title="7">return nil</span>
}

func ValidateValueParams(valueParam SearchParameter, queryableFields map[string]bool) error <span class="cov10" title="12">{
        for _, value := range valueParam.ValueParams </span><span class="cov8" title="7">{
                field := value.Field
                if strings.HasSuffix(field, ".*") </span><span class="cov3" title="2">{
                        prefix := strings.TrimSuffix(field, ".*")
                        allowed := false
                        for qField, allowedValue := range queryableFields </span><span class="cov3" title="2">{
                                if strings.HasPrefix(qField, prefix) &amp;&amp; allowedValue </span><span class="cov1" title="1">{
                                        allowed = true
                                        break</span>
                                }
                        }
                        <span class="cov3" title="2">if !allowed </span><span class="cov1" title="1">{
                                return fmt.Errorf("filtering on ValueParams fields matching '%s.*' is not permitted", prefix)
                        }</span>
                } else<span class="cov6" title="5"> {
                        allowed, exists := queryableFields[field]
                        if !exists || !allowed </span><span class="cov4" title="3">{
                                return fmt.Errorf("filtering on ValueParams field '%s' is not permitted", field)
                        }</span>
                }
        }
        <span class="cov8" title="8">return nil</span>
}

func ValidateResultOptions(resultOptions SearchResultOptions, returnableFields map[string]bool) error <span class="cov6" title="5">{
        for _, field := range resultOptions.PickFields </span><span class="cov3" title="2">{
                if _, allowed := returnableFields[field]; !allowed </span><span class="cov1" title="1">{
                        return fmt.Errorf("returning field '%s' is not permitted (1)", field)
                }</span>

                <span class="cov1" title="1">if allowed, exists := returnableFields[field]; !exists || !allowed </span><span class="cov1" title="1">{
                        if strings.HasSuffix(field, ".*") </span><span class="cov0" title="0">{
                                prefix := strings.TrimSuffix(field, ".*")
                                allowed = false
                                for f := range returnableFields </span><span class="cov0" title="0">{
                                        if strings.HasPrefix(f, prefix) </span><span class="cov0" title="0">{
                                                allowed = true
                                                break</span>
                                        }
                                }
                        }
                        <span class="cov1" title="1">if !allowed </span><span class="cov1" title="1">{
                                return fmt.Errorf("returning field '%s' is strictly forbidden (2)", field)
                        }</span>
                }
        }

        <span class="cov4" title="3">for _, field := range resultOptions.OmitFields </span><span class="cov1" title="1">{
                if _, allowed := returnableFields[field]; !allowed </span><span class="cov1" title="1">{
                        return fmt.Errorf("omitting field '%s' is not permitted", field)
                }</span>
        }

        <span class="cov3" title="2">if resultOptions.Limit == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("limit must be a positive integer")
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package steam

import (
        "time"

        "github.com/google/uuid"
        common "github.com/psavelis/team-pro/replay-api/pkg/domain"
)

type SteamUser struct {
        ID            uuid.UUID            `json:"id" bson:"_id"`
        VHash         string               `json:"v_hash" bson:"v_hash"`
        Name          string               `json:"name" bson:"name"`
        Email         string               `json:"email" bson:"email"`
        Image         string               `json:"image" bson:"image"`
        Steam         Steam                `json:"steam" bson:"steam"`
        ResourceOwner common.ResourceOwner `json:"resource_owner" bson:"resource_owner"`
        CreatedAt     time.Time            `json:"created_at" bson:"created_at"`
        UpdatedAt     time.Time            `json:"updated_at" bson:"updated_at"`
}

type Steam struct {
        ID                       string    `json:"id" bson:"_id"`
        CommunityVisibilityState int       `json:"communityvisibilitystate" bson:"communityvisibilitystate"`
        ProfileState             int       `json:"profilestate" bson:"profilestate"`
        PersonaName              string    `json:"personaname" bson:"personaname"`
        ProfileURL               string    `json:"profileurl" bson:"profileurl"`
        Avatar                   string    `json:"avatar" bson:"avatar"`
        AvatarMedium             string    `json:"avatarmedium" bson:"avatarmedium"`
        AvatarFull               string    `json:"avatarfull" bson:"avatarfull"`
        AvatarHash               string    `json:"avatarhash" bson:"avatarhash"`
        PersonaState             int       `json:"personastate" bson:"personastate"`
        RealName                 string    `json:"realname" bson:"realname"`
        PrimaryClanID            string    `json:"primaryclanid" bson:"primaryclanid"`
        TimeCreated              time.Time `json:"timecreated" bson:"timecreated"`
        PersonaStateFlags        int       `json:"personastateflags" bson:"personastateflags"`
}

func (s SteamUser) GetID() uuid.UUID <span class="cov0" title="0">{
        return s.ID
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package steam

import "fmt"

// Invalid VHash Error
type InvalidVHashError struct {
        // Error message
        Message string
}

// Error returns the error message
func (e *InvalidVHashError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// NewInvalidVHashError creates a new InvalidVHashError
func NewInvalidVHashError(invalidVHash string) *InvalidVHashError <span class="cov0" title="0">{
        return &amp;InvalidVHashError{
                Message: fmt.Sprintf("Invalid vHash: %s", invalidVHash),
        }
}</span>

// Steam User Not Found Error
type SteamUserNotFoundError struct {
        // Error message
        Message string
}

// Error returns the error message
func (e *SteamUserNotFoundError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// NewSteamUserNotFoundError creates a new SteamUserNotFoundError
func NewSteamUserNotFoundError(message string) *SteamUserNotFoundError <span class="cov0" title="0">{
        return &amp;SteamUserNotFoundError{
                Message: message,
        }
}</span>

// Steam User Already Exists Error
type SteamUserAlreadyExistsError struct {
        // Error message
        Message string
}

// Error returns the error message
func (e *SteamUserAlreadyExistsError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// NewSteamUserAlreadyExistsError creates a new SteamUserAlreadyExistsError
func NewSteamUserAlreadyExistsError(message string) *SteamUserAlreadyExistsError <span class="cov0" title="0">{
        return &amp;SteamUserAlreadyExistsError{
                Message: message,
        }
}</span>

// Steam User Creation Error
type SteamUserCreationError struct {
        // Error message
        Message string
}

// Error returns the error message
func (e *SteamUserCreationError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// NewSteamUserCreationError creates a new SteamUserCreationError
func NewSteamUserCreationError(message string) *SteamUserCreationError <span class="cov0" title="0">{
        return &amp;SteamUserCreationError{
                Message: message,
        }
}</span>

// Steam User Verification Error
type SteamUserVerificationError struct {
        // Error message
        Message string
}

// Error returns the error message
func (e *SteamUserVerificationError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// NewSteamUserVerificationError creates a new SteamUserVerificationError
func NewSteamUserVerificationError(expectedSteamID uint64, receivedSteamID uint64) *SteamUserVerificationError <span class="cov0" title="0">{
        return &amp;SteamUserVerificationError{
                Message: fmt.Sprintf("SteamID verification failed. Expected: %d, Received: %d", expectedSteamID, receivedSteamID),
        }
}</span>

type SteamIDMismatchError struct {
        // Error message
        Message string
}

// Error returns the error message
func (e *SteamIDMismatchError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// NewSteamIDMismatchError creates a new SteamIDMismatchError
func NewSteamIDMismatchError(receivedSteamID string) *SteamIDMismatchError <span class="cov0" title="0">{
        return &amp;SteamIDMismatchError{
                Message: fmt.Sprintf("SteamID mismatch: %s", receivedSteamID),
        }
}</span>

type SteamIDRequiredError struct {
        // Error message
        Message string
}

// Error returns the error message
func (e *SteamIDRequiredError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// NewSteamIDRequiredError creates a new SteamIDRequiredError
func NewSteamIDRequiredError() *SteamIDRequiredError <span class="cov0" title="0">{
        return &amp;SteamIDRequiredError{
                Message: "SteamID is required",
        }
}</span>

type VHashRequiredError struct {
        // Error message
        Message string
}

// Error returns the error message
func (e *VHashRequiredError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// NewVHashRequiredError creates a new VHashRequiredError
func NewVHashRequiredError() *VHashRequiredError <span class="cov0" title="0">{
        return &amp;VHashRequiredError{
                Message: "vHash is required",
        }
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package use_cases

import (
        "context"
        "fmt"
        "log/slog"
        "time"

        "github.com/google/uuid"
        common "github.com/psavelis/team-pro/replay-api/pkg/domain"
        "github.com/psavelis/team-pro/replay-api/pkg/domain/steam"
        steam_entity "github.com/psavelis/team-pro/replay-api/pkg/domain/steam/entities"
        steam_in "github.com/psavelis/team-pro/replay-api/pkg/domain/steam/ports/in"
        steam_out "github.com/psavelis/team-pro/replay-api/pkg/domain/steam/ports/out"
)

type OnboardSteamUserUseCase struct {
        SteamUserWriter steam_out.SteamUserWriter
        SteamUserReader steam_out.SteamUserReader
        VHashWriter     steam_out.VHashWriter
}

func (usecase *OnboardSteamUserUseCase) Validate(ctx context.Context, steamID string, vHash string) error <span class="cov4" title="2">{
        if steamID == "" </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "steamID is required", "steamID", steamID)
                return steam.NewSteamIDRequiredError()
        }</span>

        <span class="cov4" title="2">if vHash == "" </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "vHash is required", "vHash", vHash)
                return steam.NewVHashRequiredError()
        }</span>

        <span class="cov4" title="2">expectedVHash := usecase.VHashWriter.CreateVHash(ctx, steamID)

        if vHash != expectedVHash </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "vHash does not match", "steamID", steamID, "vHash", vHash, "expectedVHash", expectedVHash)
                return steam.NewInvalidVHashError(vHash)
        }</span>

        <span class="cov4" title="2">return nil</span>
}

func (usecase *OnboardSteamUserUseCase) Exec(ctx context.Context, steamID string, vHash string) (*steam_entity.SteamUser, error) <span class="cov4" title="2">{
        vhashSearch := usecase.newSearchByVHash(ctx, vHash)

        steamUserResult, err := usecase.SteamUserReader.Search(ctx, vhashSearch)

        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "error getting steam user", "err",
                        err)
                return nil, err
        }</span>

        <span class="cov4" title="2">userID := uuid.New()

        if len(steamUserResult) &gt; 0 </span><span class="cov4" title="2">{
                if steamID != steamUserResult[0].Steam.ID </span><span class="cov0" title="0">{
                        slog.ErrorContext(ctx, "steamID does not match", "steamID", steamID, "steamUser.Steam.ID", steamUserResult[0].Steam.ID)
                        return nil, steam.NewSteamIDMismatchError(steamID)
                }</span>

                <span class="cov4" title="2">return &amp;steamUserResult[0], nil</span>
        }

        <span class="cov0" title="0">user, err := usecase.SteamUserWriter.Create(ctx, steam_entity.SteamUser{
                ID:    userID,
                VHash: vHash,
                Name:  "",
                Email: "",
                Image: "",
                Steam: steam_entity.Steam{ID: steamID, CommunityVisibilityState: 0, ProfileState: 0, PersonaName: "", ProfileURL: "", Avatar: "", AvatarMedium: "", AvatarFull: "", AvatarHash: "", PersonaState: 0, RealName: "", PrimaryClanID: "", TimeCreated: time.Time{}, PersonaStateFlags: 0},
                ResourceOwner: common.ResourceOwner{
                        TenantID: common.TeamPROTenantID,
                        UserID:   userID,
                        GroupID:  uuid.Nil,
                        ClientID: common.TeamPROAppClientID,
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "error creating steam user", "err", err)
                return nil, steam.NewSteamUserCreationError(fmt.Sprintf("error creating steam user: %v", userID))
        }</span>

        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "error creating steam user", "err",
                        err)
                return nil, steam.NewSteamUserCreationError(fmt.Sprintf("unable to create steam user: %v", userID))
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func NewOnboardSteamUserUseCase(steamUserWriter steam_out.SteamUserWriter, steamUserReader steam_out.SteamUserReader, vHashWriter steam_out.VHashWriter) steam_in.OnboardSteamUserCommand <span class="cov10" title="6">{
        return &amp;OnboardSteamUserUseCase{
                SteamUserWriter: steamUserWriter, SteamUserReader: steamUserReader, VHashWriter: vHashWriter,
        }
}</span>

func (uc *OnboardSteamUserUseCase) newSearchByVHash(ctx context.Context, vhashString string) common.Search <span class="cov4" title="2">{
        params := []common.SearchAggregation{
                {
                        Params: []common.SearchParameter{
                                {
                                        ValueParams: []common.SearchableValue{
                                                {
                                                        Field: "VHash",
                                                        Values: []interface{}{
                                                                vhashString,
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }

        visibility := common.SearchVisibilityOptions{
                RequestSource:    common.GetResourceOwner(ctx),
                IntendedAudience: common.ClientApplicationAudienceIDKey,
        }

        result := common.SearchResultOptions{
                Skip:  0,
                Limit: 1,
        }

        return common.Search{
                SearchParams:      params,
                ResultOptions:     result,
                VisibilityOptions: visibility,
        }
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package blob

import (
        "context"
        "io"
        "log/slog"
        "os"

        "github.com/google/uuid"
)

type LocalFileAdapter struct{}

func NewLocalFileAdapter() *LocalFileAdapter <span class="cov0" title="0">{
        return &amp;LocalFileAdapter{}
}</span>

func (adp *LocalFileAdapter) Put(ctx context.Context, replayFileID uuid.UUID, reader io.ReadSeeker) (string, error) <span class="cov0" title="0">{
        _, err := reader.Seek(0, 0)
        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "error seeking to start of file", err)
        }</span>

        <span class="cov0" title="0">path := "/app/replay_files/" + replayFileID.String() + ".dem"
        fileBytes := []byte{}
        _, err = reader.Read(fileBytes)
        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "error reading replay file", err)
        }</span>

        <span class="cov0" title="0">file, err := os.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "error writing replay file", err)
        }</span>

        <span class="cov0" title="0">_, err = file.Write(fileBytes)
        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "error writing replay file", err)
        }</span>

        <span class="cov0" title="0">slog.InfoContext(ctx, "Local.Put: successfully wrote replay file", "path", path)

        return path, nil</span>
}

func (adapter *LocalFileAdapter) GetByID(ctx context.Context, replayFileID uuid.UUID) (*os.File, error) <span class="cov0" title="0">{
        path := "/app/replay_files/" + replayFileID.String() + ".dem"
        file, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "Local.GetByID: error reading replay file", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return file, nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package clients

import (
        "encoding/json"
        "log/slog"
        "net/http"
        "time"

        steamEntities "github.com/psavelis/team-pro/replay-api/pkg/domain/steam/entities"
)

type SteamClient struct {
        HttpClient *http.Client
}

func NewSteamClient() *SteamClient <span class="cov0" title="0">{
        return &amp;SteamClient{
                HttpClient: &amp;http.Client{
                        Transport: &amp;http.Transport{
                                MaxIdleConns:    10,
                                IdleConnTimeout: time.Second * 30,
                        },
                        Timeout: time.Second * 10,
                },
        }
}</span>

// deprecated
func (c *SteamClient) Details(token string) (*steamEntities.SteamUser, error) <span class="cov0" title="0">{
        res, err := c.HttpClient.Get("https://api.steampowered.com/ISteamUserOAuth/GetTokenDetails/v1/?access_token=" + token)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to get token details", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()

        var steamUser steamEntities.SteamUser
        json.NewDecoder(res.Body).Decode(&amp;steamUser)

        return &amp;steamUser, nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package crypto

import (
        "context"
        "crypto/sha256"
        "encoding/hex"

        steam_out "github.com/psavelis/team-pro/replay-api/pkg/domain/steam/ports/out"
)

type SHA256VHasherAdapter struct {
        VHashSource string
}

func NewSHA256VHasherAdapter(vHashSource string) steam_out.VHashWriter <span class="cov10" title="6">{
        return &amp;SHA256VHasherAdapter{VHashSource: vHashSource}
}</span>

func (v *SHA256VHasherAdapter) CreateVHash(ctx context.Context, steamID string) string <span class="cov6" title="3">{
        sha256 := sha256.New()

        sha256.Write([]byte(steamID + v.VHashSource))

        return hex.EncodeToString(sha256.Sum(nil))
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package db

import (
        "context"
        "log"
        "log/slog"
        "reflect"
        "time"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"

        replay_entity "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/entities"
)

type EventsRepository struct {
        MongoDBRepository[replay_entity.GameEvent]
}

func NewEventsRepository(client *mongo.Client, dbName string, entityType replay_entity.GameEvent, collectionName string) *EventsRepository <span class="cov0" title="0">{
        repo := MongoDBRepository[replay_entity.GameEvent]{
                mongoClient:       client,
                dbName:            dbName,
                mappingCache:      make(map[string]CacheItem),
                entityModel:       reflect.TypeOf(entityType),
                bsonFieldMappings: make(map[string]string),
                collectionName:    collectionName,
                entityName:        reflect.TypeOf(entityType).Name(),
                queryableFields:   make(map[string]bool),
        }

        repo.InitQueryableFields(map[string]bool{
                "ID":              true,
                "GameID":          true,
                "MatchID":         true,
                "Type":            true,
                "Time":            true,
                "EventData":       true,
                "PlayerStats":     true,
                "NetworkPlayerID": true,
                "PlayerName":      true,
                "ResourceOwner":   true,
                "CreatedAt":       true,
        }, map[string]string{
                "ID":              "_id",
                "GameID":          "game_id",
                "MatchID":         "match_id",
                "Type":            "type",
                "Time":            "event_time",
                "EventData":       "event_data",
                "PlayerStats":     "player_stats",
                "NetworkPlayerID": "network_player_id",
                "PlayerName":      "player_name",
                "ResourceOwner":   "resource_owner",
                "CreatedAt":       "created_at",
        })

        return &amp;EventsRepository{
                repo,
        }
}</span>

// func (r *EventsRepository) Search(ctx context.Context, s common.Search) ([]replay_entity.GameEvent, error) {
//         cursor, err := r.Query(ctx, s)
//         if cursor != nil {
//                 defer cursor.Close(ctx)
//         }

//         if err != nil {
//                 slog.ErrorContext(ctx, "error querying game events", "err", err)
//                 return nil, err
//         }

//         gameEvents := make([]replay_entity.GameEvent, 0)

//         for cursor.Next(ctx) {
//                 var replayFile replay_entity.GameEvent
//                 err := cursor.Decode(&amp;replayFile)

//                 if err != nil {
//                         slog.ErrorContext(ctx, "error decoding game event", "err", err)
//                         return nil, err
//                 }

//                 gameEvents = append(gameEvents, replayFile)
//         }

//         return gameEvents, nil
// }

// func (r *EventsRepository) CreateMany(createCtx context.Context, events []replay_entity.GameEvent) error {
//         collection := r.mongoClient.Database("replay").Collection("game_events")

//         queryCtx, cancel := context.WithTimeout(createCtx, 10*time.Second)
//         defer cancel()

//         toInsert := make([]interface{}, len(events))

//         for i := range events {
//                 toInsert[i] = events[i]
//         }

//         _, err := collection.InsertMany(queryCtx, toInsert)
//         if err != nil {
//                 slog.ErrorContext(queryCtx, err.Error())
//                 return err
//         }

//         return nil
// }

func (r *EventsRepository) GetByGameIDAndMatchID(queryCtx context.Context, gameID string, matchID string) ([]replay_entity.GameEvent, error) <span class="cov0" title="0">{
        collection := r.mongoClient.Database(r.dbName).Collection(r.collectionName)

        queryCtx, cancel := context.WithTimeout(queryCtx, 10*time.Second)
        defer cancel()

        query := bson.D{
                {Key: "game_id", Value: gameID},
                {Key: "match_id", Value: matchID},
        }

        cur, err := collection.Find(queryCtx, query)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">defer cur.Close(queryCtx)

        res := []replay_entity.GameEvent{}
        for cur.Next(queryCtx) </span><span class="cov0" title="0">{
                var event *replay_entity.GameEvent
                err := cur.Decode(&amp;event)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">res = append(res, *event)</span>
        }

        <span class="cov0" title="0">if err := cur.Err(); err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(queryCtx, err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">return res, nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package db

import (
        "reflect"

        replay_entity "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/entities"
        "go.mongodb.org/mongo-driver/mongo"
)

type MatchMetadataRepository struct {
        MongoDBRepository[replay_entity.Match]
}

func NewMatchMetadataRepository(client *mongo.Client, dbName string, entityType replay_entity.Match, collectionName string) *MatchMetadataRepository <span class="cov8" title="1">{
        repo := MongoDBRepository[replay_entity.Match]{
                mongoClient:       client,
                dbName:            dbName,
                mappingCache:      make(map[string]CacheItem),
                entityModel:       reflect.TypeOf(entityType),
                bsonFieldMappings: make(map[string]string),
                collectionName:    collectionName,
                entityName:        reflect.TypeOf(entityType).Name(),
                queryableFields:   make(map[string]bool),
        }

        repo.InitQueryableFields(map[string]bool{
                "ID":                             true,
                "ReplayFileID":                   true,
                "GameID":                         true,
                "Visibility":                     true,
                "ResourceOwner":                  true,
                "CreatedAt":                      true,
                "UpdatedAt":                      true,
                "Scoreboard":                     true,
                "Events":                         true,
                "ShareTokens.*":                  true,
                "Scoreboard.MVP":                 true,
                "Scoreboard.Teams":               true,
                "Scoreboard.Teams.MVP":           true,
                "Scoreboard.Teams.Players":       true,
                "Scoreboard.Teams.Players.Stats": true,
                "Scoreboard.Teams.Rounds":        true,
                "Scoreboard.Teams.Rounds.Stats":  true,
        }, map[string]string{
                "ID":                             "_id",
                "ReplayFileID":                   "replay_file_id",
                "GameID":                         "game_id",
                "Visibility":                     "visibility",
                "ResourceOwner":                  "resource_owner",
                "CreatedAt":                      "created_at",
                "UpdatedAt":                      "updated_at",
                "Scoreboard":                     "scoreboard",
                "Events":                         "game_events",
                "ShareTokens":                    "share_tokens",
                "Scoreboard.MVP":                 "scoreboard.match_mvp",
                "Scoreboard.Teams":               "scoreboard.team_scoreboards",
                "Scoreboard.Teams.MVP":           "scoreboard.team_mvp",
                "Scoreboard.Teams.Players":       "scoreboard.team_scoreboards.players",
                "Scoreboard.Teams.Players.Stats": "scoreboard.team_scoreboards.player_stats",
                "Scoreboard.Teams.Rounds":        "scoreboard.team_scoreboards.rounds",
                "Scoreboard.Teams.Rounds.Stats":  "scoreboard.team_scoreboards.round_stats",
        })

        return &amp;MatchMetadataRepository{
                repo,
        }
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package db

import (
        "context"
        "fmt"
        "log/slog"
        "reflect"
        "strings"
        "time"

        "github.com/google/uuid"
        common "github.com/psavelis/team-pro/replay-api/pkg/domain"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
)

const (
        MAX_RECURSIVE_DEPTH = 10 // disabled, to do next. (default=10)
)

type CacheItem map[string]string

type MongoDBRepository[T common.Entity] struct {
        mongoClient       *mongo.Client
        dbName            string
        mappingCache      map[string]CacheItem
        entityModel       reflect.Type
        collectionName    string
        entityName        string
        bsonFieldMappings map[string]string // Local mapping of field names
        queryableFields   map[string]bool
}

type MongoDBRepositoryBuilder[T common.BaseEntity] struct {
}

func (r *MongoDBRepository[T]) InitQueryableFields(queryableFields map[string]bool, bsonFieldMappings map[string]string) <span class="cov4" title="8">{
        r.queryableFields = queryableFields

        for k, v := range bsonFieldMappings </span><span class="cov10" title="129">{
                r.bsonFieldMappings[k] = v
        }</span>
}

func (r *MongoDBRepository[T]) GetBSONFieldName(fieldName string) (string, error) <span class="cov3" title="4">{
        if cachedBSONName, exists := r.mappingCache[r.entityName][fieldName]; exists </span><span class="cov1" title="1">{
                return cachedBSONName, nil
        }</span>

        <span class="cov3" title="3">fieldParts := strings.Split(fieldName, ".")
        currentType := r.entityModel
        bsonFieldName := ""

        for i, part := range fieldParts </span><span class="cov3" title="3">{
                field, ok := currentType.FieldByName(part)
                if !ok </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("field %s (of %s) not found", part, currentType.Name())
                }</span>

                <span class="cov3" title="3">bsonTag := field.Tag.Get("bson")
                if bsonTag == "" </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("field %s (of %s) does not have bson-tag", part, currentType.Name())
                }</span>

                <span class="cov3" title="3">if bsonFieldName != "" </span><span class="cov0" title="0">{
                        bsonFieldName += "."
                }</span>
                <span class="cov3" title="3">bsonFieldName += bsonTag

                if bsonTag == "*" &amp;&amp; i &lt; len(fieldParts)-1 </span><span class="cov0" title="0">{
                        return bsonFieldName, nil
                }</span>

                <span class="cov3" title="3">if field.Type.Kind() == reflect.Struct &amp;&amp; i &lt; len(fieldParts)-1 </span><span class="cov0" title="0">{
                        currentType = field.Type
                }</span>
        }

        <span class="cov3" title="3">if _, exists := r.mappingCache[r.entityName]; !exists </span><span class="cov3" title="3">{
                r.mappingCache[r.entityName] = make(CacheItem)
        }</span>
        <span class="cov3" title="3">r.mappingCache[r.entityName][fieldName] = bsonFieldName

        return bsonFieldName, nil</span>
}

func (repo *MongoDBRepository[T]) Compile(ctx context.Context, searchParams []common.SearchAggregation, resultOptions common.SearchResultOptions) (*common.Search, error) <span class="cov0" title="0">{
        err := common.ValidateSearchParameters(searchParams, repo.queryableFields)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error validating search parameters: %v", err)
        }</span>

        <span class="cov0" title="0">err = repo.ValidateBSONSetup(resultOptions, repo.bsonFieldMappings)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error validating result options: %v", err)
        }</span>

        <span class="cov0" title="0">s := common.NewSearchByAggregation(ctx, searchParams, resultOptions, common.UserAudienceIDKey)

        return &amp;s, nil</span>
}

func (repo *MongoDBRepository[T]) ValidateBSONSetup(resultOptions common.SearchResultOptions, bsonFieldMappings map[string]string) error <span class="cov0" title="0">{
        if len(resultOptions.PickFields) &gt; 0 &amp;&amp; len(resultOptions.OmitFields) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot specify both pick and omit fields")
        }</span>

        <span class="cov0" title="0">for _, field := range resultOptions.PickFields </span><span class="cov0" title="0">{
                if _, ok := bsonFieldMappings[field]; !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("field %s is not a valid field to pick", field)
                }</span>
        }

        <span class="cov0" title="0">for _, field := range resultOptions.OmitFields </span><span class="cov0" title="0">{
                if _, ok := bsonFieldMappings[field]; !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("field %s is not a valid field to omit", field)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (r *MongoDBRepository[T]) Query(queryCtx context.Context, s common.Search) (*mongo.Cursor, error) <span class="cov6" title="20">{
        collection := r.mongoClient.Database(r.dbName).Collection(r.collectionName)

        pipe, err := r.GetPipeline(queryCtx, s)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="20">cursor, err := collection.Aggregate(queryCtx, pipe)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="20">return cursor, nil</span>
}

func (r *MongoDBRepository[T]) GetPipeline(queryCtx context.Context, s common.Search) ([]bson.M, error) <span class="cov6" title="20">{
        var pipe []bson.M

        pipe, err := r.addMatch(queryCtx, pipe, s)

        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(queryCtx, "GetPipeline: unable to build $match stage", "error", err)
                return nil, err
        }</span>

        <span class="cov6" title="20">pipe = r.addProjection(pipe, s)
        pipe = r.addSort(pipe, s)
        pipe = r.addSkip(pipe, s)
        pipe = r.addLimit(pipe, s)

        var pipeString string
        for _, stage := range pipe </span><span class="cov8" title="61">{
                pipeString += fmt.Sprintf("%v\n", stage)
        }</span>

        <span class="cov6" title="20">slog.InfoContext(queryCtx, "GetPipeline: built pipeline", "pipeline", pipeString)

        return pipe, nil</span>
}

func (r *MongoDBRepository[T]) addLimit(pipe []bson.M, s common.Search) []bson.M <span class="cov6" title="20">{
        pipe = append(pipe, bson.M{"$limit": s.ResultOptions.Limit})
        return pipe
}</span>

func (r *MongoDBRepository[T]) addSkip(pipe []bson.M, s common.Search) []bson.M <span class="cov6" title="20">{
        pipe = append(pipe, bson.M{"$skip": s.ResultOptions.Skip})
        return pipe
}</span>

func (r *MongoDBRepository[T]) addSort(pipe []bson.M, s common.Search) []bson.M <span class="cov6" title="20">{
        sortFields := []bson.D{}
        for _, sortOption := range s.SortOptions </span><span class="cov0" title="0">{
                sortFields = append(sortFields, bson.D{{Key: sortOption.Field, Value: sortOption.Direction}})
        }</span>
        <span class="cov6" title="20">sortStage := bson.M{"$sort": sortFields}

        if (sortFields != nil) &amp;&amp; (len(sortFields) &gt; 0) </span><span class="cov0" title="0">{
                pipe = append(pipe, sortStage)
        }</span>
        <span class="cov6" title="20">return pipe</span>
}

func (r *MongoDBRepository[T]) addMatch(queryCtx context.Context, pipe []bson.M, s common.Search) ([]bson.M, error) <span class="cov6" title="20">{
        aggregate := bson.M{}
        for _, aggregator := range s.SearchParams </span><span class="cov6" title="20">{
                r.setMatchValues(queryCtx, aggregator.Params, &amp;aggregate)
        }</span>

        <span class="cov6" title="20">aggregate, err := r.EnsureTenancy(queryCtx, aggregate, s)

        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(queryCtx, "Pipeline (addMatch) aborted due to inconsistent tenancy", "err", err.Error())
                return nil, err
        }</span>

        <span class="cov6" title="20">pipe = append(pipe, bson.M{"$match": aggregate})
        return pipe, nil</span>
}

func (r *MongoDBRepository[T]) setMatchValues(queryCtx context.Context, params []common.SearchParameter, aggregate *bson.M) <span class="cov6" title="20">{
        if r.queryableFields == nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("queryableFields not initialized in MongoDBRepository of %s", r.entityName))</span>
        }

        <span class="cov6" title="20">for _, p := range params </span><span class="cov6" title="20">{
                // Handle ValueParams
                for _, v := range p.ValueParams </span><span class="cov6" title="19">{
                        bsonFieldName, err := r.GetBSONFieldNameFromSearchableValue(v)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(err)</span> // Retain panic for irrecoverable errors
                        }

                        // Check if the prefix is allowed
                        <span class="cov6" title="19">if strings.HasSuffix(v.Field, ".*") </span><span class="cov0" title="0">{
                                prefix := strings.TrimSuffix(v.Field, ".*")
                                if !isPrefixAllowed(prefix, r.queryableFields) </span><span class="cov0" title="0">{
                                        panic(fmt.Errorf("filtering on fields matching '%s.*' is not permitted", prefix))</span>
                                }
                        }

                        <span class="cov6" title="19">filter := buildFilterForOperator(v.Operator, v.Values)
                        if filter == nil </span><span class="cov0" title="0">{
                                continue</span> //Skip this value if not supported
                        }

                        // Build filter based on operator (default to $in if not specified)
                        <span class="cov6" title="19">if strings.HasSuffix(v.Field, ".*") &amp;&amp; strings.Contains(bsonFieldName, ".") </span><span class="cov0" title="0">{
                                // Nested field with wildcard: use $elemMatch
                                (*aggregate)[bsonFieldName] = bson.M{"$elemMatch": filter}
                        }</span> else<span class="cov6" title="19"> {
                                (*aggregate)[bsonFieldName] = filter
                        }</span>

                        <span class="cov6" title="19">slog.InfoContext(queryCtx, "query: %v, value: %v", bsonFieldName, v.Values)</span>
                }

                // Handle DateParams
                <span class="cov6" title="20">for _, d := range p.DateParams </span><span class="cov2" title="2">{
                        bsonFieldName, err := r.GetBSONFieldName(d.Field)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(err)</span> // Retain panic for irrecoverable reflection errors
                        }

                        <span class="cov2" title="2">dateFilter := bson.M{}
                        if d.Min != nil </span><span class="cov2" title="2">{
                                dateFilter["$gte"] = *d.Min
                        }</span>
                        <span class="cov2" title="2">if d.Max != nil </span><span class="cov2" title="2">{
                                dateFilter["$lte"] = *d.Max
                        }</span>
                        <span class="cov2" title="2">(*aggregate)[bsonFieldName] = dateFilter</span>
                }

                // Handle DurationParams (similar to DateParams)
                <span class="cov6" title="20">for _, dur := range p.DurationParams </span><span class="cov0" title="0">{
                        bsonFieldName, err := r.GetBSONFieldName(dur.Field)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(err)</span> // Retain panic for irrecoverable reflection errors
                        }

                        <span class="cov0" title="0">durationFilter := bson.M{}
                        if dur.Min != nil </span><span class="cov0" title="0">{
                                durationFilter["$gte"] = *dur.Min
                        }</span>
                        <span class="cov0" title="0">if dur.Max != nil </span><span class="cov0" title="0">{
                                durationFilter["$lte"] = *dur.Max
                        }</span>
                        <span class="cov0" title="0">(*aggregate)[bsonFieldName] = durationFilter</span>
                }

                <span class="cov6" title="20">if p.AggregationParams == nil </span><span class="cov6" title="20">{
                        continue</span>
                }

                <span class="cov0" title="0">for i, v := range p.AggregationParams </span><span class="cov0" title="0">{
                        if i+1 &gt;= MAX_RECURSIVE_DEPTH </span><span class="cov0" title="0">{
                                slog.WarnContext(queryCtx, "setMatchValue MaxRecursiveDepth exceeded", "depth", i, "MAX_RECURSIVE_DEPTH", MAX_RECURSIVE_DEPTH, "params", p.AggregationParams)
                                break</span>
                        }

                        <span class="cov0" title="0">innerAggregate := bson.M{}
                        r.setMatchValues(queryCtx, v.Params, &amp;innerAggregate)
                        (*aggregate)["$and"] = append((*aggregate)["$and"].([]bson.M), innerAggregate)</span>
                }
        }
}

// Helper function to build the filter based on the operator
func buildFilterForOperator(operator common.SearchOperator, values []interface{}) bson.M <span class="cov6" title="19">{
        switch operator </span>{
        case common.EqualsOperator:<span class="cov1" title="1">
                return bson.M{"$eq": values[0]}</span>
        case common.NotEqualsOperator:<span class="cov0" title="0">
                return bson.M{"$ne": values[0]}</span>
        case common.GreaterThanOperator:<span class="cov1" title="1">
                return bson.M{"$gt": values[0]}</span>
        case common.LessThanOperator:<span class="cov1" title="1">
                return bson.M{"$lt": values[0]}</span>
        case common.GreaterThanOrEqualOperator:<span class="cov0" title="0">
                return bson.M{"$gte": values[0]}</span>
        case common.LessThanOrEqualOperator:<span class="cov0" title="0">
                return bson.M{"$lte": values[0]}</span>
        case common.ContainsOperator:<span class="cov2" title="2">
                return bson.M{"$regex": values[0], "$options": "i"}</span>
        case common.StartsWithOperator:<span class="cov0" title="0">
                return bson.M{"$regex": "^" + fmt.Sprintf("%v", values[0]), "$options": "i"}</span>
        case common.EndsWithOperator:<span class="cov0" title="0">
                return bson.M{"$regex": fmt.Sprintf("%v", values[0]) + "$", "$options": "i"}</span>
        case common.InOperator:<span class="cov1" title="1">
                return bson.M{"$in": values}</span>
        case common.NotInOperator:<span class="cov0" title="0">
                return bson.M{"$nin": values}</span>
        default:<span class="cov5" title="13">
                return bson.M{"$in": values}</span>
        }
}

// helper function to reuse code when checking prefix
func isPrefixAllowed(prefix string, queryableFields map[string]bool) bool <span class="cov0" title="0">{
        for allowedField := range queryableFields </span><span class="cov0" title="0">{
                if strings.HasPrefix(allowedField, prefix) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (r *MongoDBRepository[T]) GetBSONFieldNameFromSearchableValue(v common.SearchableValue) (string, error) <span class="cov7" title="35">{
        // Check for wildcard and handle directly
        if strings.HasSuffix(v.Field, ".*") </span><span class="cov1" title="1">{
                return r.GetBSONFieldName(v.Field[:len(v.Field)-2])
        }</span>

        // Direct lookup in the mapping
        <span class="cov7" title="34">if bsonFieldName, ok := r.bsonFieldMappings[v.Field]; ok </span><span class="cov7" title="30">{
                return bsonFieldName, nil
        }</span>

        <span class="cov3" title="4">slog.Warn("GetBSONFieldNameFromSearchableValue: field not found in mapping", "field", v.Field, "v", v)

        if v.Field == "" </span><span class="cov1" title="1">{
                return "", fmt.Errorf("empty field not allowed. cant query")
        }</span>

        <span class="cov3" title="3">return "", fmt.Errorf("field %s not found or not queryable in %s", v.Field, r.entityName)</span>
}

func (r *MongoDBRepository[T]) Create(ctx context.Context, entity T) (*T, error) <span class="cov0" title="0">{
        collection := r.mongoClient.Database(r.dbName).Collection(r.collectionName)

        queryCtx, cancel := context.WithTimeout(ctx, 5*time.Second)
        defer cancel()

        _, err := collection.InsertOne(queryCtx, entity)
        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(queryCtx, err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;entity, nil</span>
}

func (r *MongoDBRepository[T]) CreateMany(ctx context.Context, entities []T) error <span class="cov0" title="0">{
        collection := r.mongoClient.Database(r.dbName).Collection(r.collectionName)

        queryCtx, cancel := context.WithTimeout(ctx, 10*time.Second)
        defer cancel()

        toInsert := make([]interface{}, len(entities))

        for i, e := range entities </span><span class="cov0" title="0">{
                toInsert[i] = e
        }</span>

        <span class="cov0" title="0">_, err := collection.InsertMany(queryCtx, toInsert)
        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(queryCtx, err.Error())
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *MongoDBRepository[T]) addProjection(pipe []bson.M, s common.Search) []bson.M <span class="cov6" title="20">{
        var projection *bson.M
        if len(s.ResultOptions.PickFields) &gt; 0 </span><span class="cov1" title="1">{
                projection = &amp;bson.M{}
                for _, field := range s.ResultOptions.PickFields </span><span class="cov2" title="2">{
                        (*projection)[field] = 1
                }</span>
        } else<span class="cov6" title="19"> if len(s.ResultOptions.OmitFields) &gt; 0 </span><span class="cov0" title="0">{
                projection = &amp;bson.M{}
                for _, field := range s.ResultOptions.OmitFields </span><span class="cov0" title="0">{
                        (*projection)[field] = 0
                }</span>
        }

        <span class="cov6" title="20">if projection != nil </span><span class="cov1" title="1">{
                pipe = append(pipe, bson.M{"$project": *projection})
        }</span>
        <span class="cov6" title="20">return pipe</span>
}

func (r *MongoDBRepository[T]) EnsureTenancy(queryCtx context.Context, agg bson.M, s common.Search) (bson.M, error) <span class="cov7" title="28">{
        tenantID, ok := queryCtx.Value(common.TenantIDKey).(uuid.UUID)
        if !ok || tenantID == uuid.Nil </span><span class="cov1" title="1">{
                return agg, fmt.Errorf("TENANCY.RequestSource: valid tenant_id is required in queryCtx: %#v", queryCtx)
        }</span>

        <span class="cov7" title="27">if s.VisibilityOptions.RequestSource.TenantID == uuid.Nil </span><span class="cov0" title="0">{
                return agg, fmt.Errorf("TENANCY.RequestSource: `tenant_id` is required but not provided in `common.Search`: %#v", s)
        }</span> else<span class="cov7" title="27"> if tenantID != s.VisibilityOptions.RequestSource.TenantID </span><span class="cov0" title="0">{
                return agg, fmt.Errorf("TENANCY.RequestSource: `tenant_id` in queryCtx does not match `tenant_id` in `common.Search`: %v vs %v", tenantID, s.VisibilityOptions.RequestSource.TenantID)
        }</span>

        <span class="cov7" title="27">agg["resource_owner.tenant_id"] = tenantID

        switch s.VisibilityOptions.IntendedAudience </span>{
        case common.ClientApplicationAudienceIDKey:<span class="cov5" title="10">
                return ensureClientID(queryCtx, agg, s)</span>

        case common.GroupAudienceIDKey:<span class="cov3" title="3">
                return ensureGroupID(queryCtx, agg, s)</span>

        case common.UserAudienceIDKey:<span class="cov5" title="13">
                return ensureUserID(queryCtx, agg, s)</span>

        case common.TenantAudienceIDKey:<span class="cov0" title="0">
                return agg, fmt.Errorf("TENANCY.Admin: tenant audience is not allowed")</span>

        default:<span class="cov1" title="1">
                return agg, fmt.Errorf("TENANCY.Unknown: intended audience %s is invalid in `common.Search`: %#v", s.VisibilityOptions.IntendedAudience, s)</span>
        }
}

func ensureClientID(ctx context.Context, agg bson.M, s common.Search) (bson.M, error) <span class="cov5" title="10">{
        clientID, ok := ctx.Value(common.ClientIDKey).(uuid.UUID)
        if !ok || clientID == uuid.Nil </span><span class="cov1" title="1">{
                return agg, fmt.Errorf("TENANCY.ApplicationLevel: valid client_id is required in queryCtx: %#v", ctx)
        }</span>

        <span class="cov5" title="9">if s.VisibilityOptions.RequestSource.ClientID == uuid.Nil </span><span class="cov0" title="0">{
                return agg, fmt.Errorf("TENANCY.ApplicationLevel: `client_id` is required in `common.Search`: %#v", s)
        }</span>

        <span class="cov5" title="9">if clientID != s.VisibilityOptions.RequestSource.ClientID </span><span class="cov0" title="0">{
                return agg, fmt.Errorf("TENANCY.ApplicationLevel: `client_id` in queryCtx does not match `client_id` in `common.Search`: %v vs %v", clientID, s.VisibilityOptions.RequestSource.ClientID)
        }</span>

        <span class="cov5" title="9">agg["resource_owner.client_id"] = clientID
        return agg, nil</span>
}

func ensureGroupID(ctx context.Context, agg bson.M, s common.Search) (bson.M, error) <span class="cov3" title="3">{
        groupID, ok := ctx.Value(common.GroupIDKey).(uuid.UUID)
        if !ok || groupID == uuid.Nil </span><span class="cov1" title="1">{
                return agg, fmt.Errorf("TENANCY.GroupLevel: valid group_id is required in queryCtx: %#v", ctx)
        }</span>

        <span class="cov2" title="2">if s.VisibilityOptions.RequestSource.GroupID == uuid.Nil </span><span class="cov0" title="0">{
                return agg, fmt.Errorf("TENANCY.GroupLevel: `group_id` is required in `common.Search`: %#v", s)
        }</span>

        <span class="cov2" title="2">if groupID != s.VisibilityOptions.RequestSource.GroupID </span><span class="cov0" title="0">{
                return agg, fmt.Errorf("TENANCY.GroupLevel: `group_id` in queryCtx does not match `group_id` in `common.Search`: %v vs %v", groupID, s.VisibilityOptions.RequestSource.GroupID)
        }</span>

        <span class="cov2" title="2">agg["resource_owner.group_id"] = groupID
        return agg, nil</span>
}

func ensureUserID(ctx context.Context, agg bson.M, s common.Search) (bson.M, error) <span class="cov5" title="13">{
        userID, ok := ctx.Value(common.UserIDKey).(uuid.UUID)
        if !ok || userID == uuid.Nil </span><span class="cov1" title="1">{
                return agg, fmt.Errorf("TENANCY.EndUser: valid user_id is required in queryCtx: %#v", ctx)
        }</span>

        <span class="cov5" title="12">if s.VisibilityOptions.RequestSource.UserID == uuid.Nil </span><span class="cov0" title="0">{
                return agg, fmt.Errorf("TENANCY.EndUser: `user_id` is required in `common.Search`: %#v", s)
        }</span>

        <span class="cov5" title="12">if userID != s.VisibilityOptions.RequestSource.UserID </span><span class="cov0" title="0">{
                return agg, fmt.Errorf("TENANCY.EndUser: `user_id` in queryCtx does not match `user_id` in `common.Search`: %v vs %v", userID, s.VisibilityOptions.RequestSource.UserID)
        }</span>

        <span class="cov5" title="12">agg["resource_owner.user_id"] = userID
        return agg, nil</span>
}

func (r *MongoDBRepository[T]) Search(ctx context.Context, s common.Search) ([]T, error) <span class="cov3" title="4">{
        cursor, err := r.Query(ctx, s)
        if cursor != nil </span><span class="cov3" title="4">{
                defer cursor.Close(ctx)
        }</span>

        <span class="cov3" title="4">if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, fmt.Sprintf("error querying on %s (%#v) (defaultSearch)", r.entityName, r), "err", err, "search", s)
                return nil, err
        }</span>

        <span class="cov3" title="4">filesMetadata := make([]T, 0)

        for cursor.Next(ctx) </span><span class="cov3" title="5">{
                var entity T
                err := cursor.Decode(&amp;entity)

                if err != nil </span><span class="cov0" title="0">{
                        slog.ErrorContext(ctx, "error decoding replay file metadata", "err", err)
                        return nil, err
                }</span>

                <span class="cov3" title="5">filesMetadata = append(filesMetadata, entity)</span>
        }

        <span class="cov3" title="4">return filesMetadata, nil</span>
}

func (r *MongoDBRepository[T]) GetByID(queryCtx context.Context, id uuid.UUID) (*T, error) <span class="cov0" title="0">{
        collection := r.mongoClient.Database(r.dbName).Collection("replay_file_metadata")

        queryCtx, cancel := context.WithTimeout(queryCtx, 10*time.Second)
        defer cancel()

        var entity T

        query := bson.D{
                {Key: "_id", Value: id},
        }

        err := collection.FindOne(queryCtx, query).Decode(&amp;entity)
        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(queryCtx, err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;entity, nil</span>
}

func (r *MongoDBRepository[T]) Update(createCtx context.Context, entity T) (*T, error) <span class="cov0" title="0">{
        collection := r.mongoClient.Database(r.dbName).Collection("replay_file_metadata")

        queryCtx, cancel := context.WithTimeout(createCtx, 10*time.Second)
        defer cancel()

        _, err := collection.UpdateOne(queryCtx, bson.M{"_id": entity.GetID()}, bson.M{"$set": entity})
        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(queryCtx, err.Error(), "entity", entity)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;entity, nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package db

import (
        "context"
        "io"
        "log/slog"
        "os"

        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/gridfs"
        "go.mongodb.org/mongo-driver/mongo/options"

        "github.com/google/uuid"
)

type ReplayFileContentRepository struct {
        client *mongo.Client
        bucket *gridfs.Bucket
}

func NewReplayFileContentRepository(client *mongo.Client) *ReplayFileContentRepository <span class="cov0" title="0">{
        db := client.Database("replay")
        bucket, err := gridfs.NewBucket(db, options.GridFSBucket().SetName("replay_file_content"))

        if err != nil </span><span class="cov0" title="0">{
                slog.Warn("error creating gridfs bucket", err)
        }</span>

        <span class="cov0" title="0">return &amp;ReplayFileContentRepository{
                client: client,
                bucket: bucket,
        }</span>
}

func (r *ReplayFileContentRepository) GetByID(ctx context.Context, replayFileID uuid.UUID) (io.ReadSeekCloser, error) <span class="cov0" title="0">{
        fileName := replayFileID.String() + ".dem"
        file, err := os.Create("/app/replay_files/" + fileName)
        ioWriteCloser := io.WriteCloser(file)
        file.Chmod(0500)

        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "error creating file", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">length, err := r.bucket.DownloadToStreamByName(fileName, ioWriteCloser)
        ioWriteCloser.Close()
        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "error downloading file", "length", length, "err", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">file.Truncate(0)

        file, err = os.Open("/app/replay_files/" + fileName)
        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "error opening file", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">slog.InfoContext(ctx, "ReplayFileContentRepository.GetByID: successfully downloaded file", "fileName", fileName)

        // _, err = file.Seek(0, 0)
        // if err != nil {
        //         slog.ErrorContext(ctx, "error seeking to start of file", err)
        // }

        return file, nil</span>
}

func (r *ReplayFileContentRepository) Put(ctx context.Context, replayFileID uuid.UUID, file io.ReadSeeker) (string, error) <span class="cov0" title="0">{
        fileName := replayFileID.String() + ".dem"
        _, err := file.Seek(0, 0)
        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "error seeking to start of file", err)
        }</span>

        <span class="cov0" title="0">_, err = r.bucket.UploadFromStream(fileName, file)
        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "error uploading file", err)
                return "", err
        }</span>

        <span class="cov0" title="0">slog.InfoContext(ctx, "ReplayFileContentRepository.Put: successfully uploaded file", "fileName", fileName)

        return fileName, nil</span>

}
</pre>
		
		<pre class="file" id="file56" style="display: none">package db

import (
        "reflect"

        replay_entity "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/entities"
        "go.mongodb.org/mongo-driver/mongo"
)

type ReplayFileMetadataRepository struct {
        MongoDBRepository[replay_entity.ReplayFile]
}

func NewReplayFileMetadataRepository(client *mongo.Client, dbName string, entityType replay_entity.ReplayFile, collectionName string) *ReplayFileMetadataRepository <span class="cov10" title="4">{
        repo := MongoDBRepository[replay_entity.ReplayFile]{
                mongoClient:       client,
                dbName:            dbName,
                mappingCache:      make(map[string]CacheItem),
                entityModel:       reflect.TypeOf(entityType),
                bsonFieldMappings: make(map[string]string),
                collectionName:    collectionName,
                entityName:        reflect.TypeOf(entityType).Name(),
                queryableFields:   make(map[string]bool),
        }

        repo.InitQueryableFields(map[string]bool{
                "ID":               true,
                "GameID":           true,
                "NetworkID":        true,
                "Size":             true,
                "InternalURI":      true,
                "Status":           true,
                "Error":            true,
                "Header":           true,
                "Header.Filestamp": true,
                "ResourceOwner":    true,
                "CreatedAt":        true,
                "UpdatedAt":        true,
        }, map[string]string{
                "ID":                     "_id",
                "GameID":                 "game_id",
                "NetworkID":              "network_id",
                "Size":                   "size",
                "InternalURI":            "uri",
                "Status":                 "status",
                "Error":                  "error",
                "Header":                 "header",
                "ResourceOwner":          "resource_owner",
                "CreatedAt":              "created_at",
                "UpdatedAt":              "updated_at",
                "Header.Filestamp":       "header.filestamp",
                "ResourceOwner.TenantID": "resource_owner.tenant_id",
                "ResourceOwner.UserID":   "resource_owner.user_id",
                "ResourceOwner.GroupID":  "resource_owner.group_id",
                "ResourceOwner.ClientID": "resource_owner.client_id",
        })

        return &amp;ReplayFileMetadataRepository{
                repo,
        }
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package db

import (
        "reflect"

        "go.mongodb.org/mongo-driver/mongo"

        iam_entity "github.com/psavelis/team-pro/replay-api/pkg/domain/iam/entities"
)

type RIDTokenRepository struct {
        MongoDBRepository[iam_entity.RIDToken]
}

func NewRIDTokenRepository(client *mongo.Client, dbName string, entityType iam_entity.RIDToken, collectionName string) *RIDTokenRepository <span class="cov0" title="0">{
        repo := MongoDBRepository[iam_entity.RIDToken]{
                mongoClient:       client,
                dbName:            dbName,
                mappingCache:      make(map[string]CacheItem),
                entityModel:       reflect.TypeOf(entityType),
                bsonFieldMappings: make(map[string]string),
                collectionName:    collectionName,
                entityName:        reflect.TypeOf(entityType).Name(),
                queryableFields:   make(map[string]bool),
        }

        repo.InitQueryableFields(map[string]bool{
                "ID":                     true,
                "Key":                    true,
                "Source":                 true,
                "ResourceOwner":          true,
                "ExpiresAt":              true,
                "CreatedAt":              true,
                "UpdatedAt":              true,
                "ResourceOwner.TenantID": true,
                "ResourceOwner.UserID":   true,
                "ResourceOwner.GroupID":  true,
                "ResourceOwner.ClientID": true,
        }, map[string]string{
                "ID":                     "_id",
                "Key":                    "key",
                "Source":                 "source",
                "ResourceOwner":          "resource_owner",
                "ExpiresAt":              "expires_at",
                "CreatedAt":              "created_at",
                "UpdatedAt":              "updated_at",
                "ResourceOwner.TenantID": "resource_owner.tenant_id",
                "ResourceOwner.UserID":   "resource_owner.user_id",
                "ResourceOwner.GroupID":  "resource_owner.group_id",
                "ResourceOwner.ClientID": "resource_owner.client_id",
        })

        return &amp;RIDTokenRepository{
                repo,
        }
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package db

import (
        "reflect"

        steam_entity "github.com/psavelis/team-pro/replay-api/pkg/domain/steam/entities"
        "go.mongodb.org/mongo-driver/mongo"
)

type SteamUserRepository struct {
        MongoDBRepository[steam_entity.SteamUser]
}

func NewSteamUserMongoDBRepository(client *mongo.Client, dbName string, entityType steam_entity.SteamUser, collectionName string) *SteamUserRepository <span class="cov0" title="0">{
        repo := MongoDBRepository[steam_entity.SteamUser]{
                mongoClient:       client,
                dbName:            dbName,
                mappingCache:      make(map[string]CacheItem),
                entityModel:       reflect.TypeOf(entityType),
                bsonFieldMappings: make(map[string]string),
                collectionName:    collectionName,
                entityName:        reflect.TypeOf(entityType).Name(),
                queryableFields:   make(map[string]bool),
        }

        repo.InitQueryableFields(map[string]bool{
                "ID":      true,
                "VHash":   true,
                "Steam.*": true,
        }, map[string]string{
                "ID":       "_id",
                "VHash":    "v_hash",
                "Steam":    "steam",
                "Steam.ID": "steam._id",
        })

        return &amp;SteamUserRepository{
                repo,
        }
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package main

import (
        "log"

        "github.com/streadway/amqp"
)

func failOnError(err error, msg string) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("%s: %s", msg, err)
                panic(err)</span>
        }
}

func main() <span class="cov0" title="0">{
        conn, err := amqp.Dial("amqp://rabbitmq:rabbitmq@localhost:5778/")
        failOnError(err, "Failed to connect to RabbitMQ")
        defer conn.Close()

        ch, err := conn.Channel()
        failOnError(err, "Failed to open a channel")
        defer ch.Close()

        q, err := ch.QueueDeclare(
                "test-q", // name
                true,     // durable
                false,    // delete when unused
                false,    // exclusive
                false,    // no-wait
                nil,      // arguments
        )
        failOnError(err, "Failed to declare a queue")

        body := "test-msg"

        for </span><span class="cov0" title="0">{
                err = ch.Publish(
                        "",     // exchange
                        q.Name, // routing key
                        false,  // mandatory
                        false,  // immediate
                        amqp.Publishing{
                                ContentType: "text/plain",
                                Body:        []byte(body),
                        })

                log.Printf(" [x] Sent %s", body)
                failOnError(err, "Failed to publish a message")
        }</span>

}
</pre>
		
		<pre class="file" id="file60" style="display: none">package ioc

import (
        "context"
        "log/slog"
        "os"
        "time"

        // env
        "github.com/joho/godotenv"

        // mongodb
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"

        // repositories/db
        "github.com/psavelis/team-pro/replay-api/pkg/infra/db"

        // messageBroker (kafka/rabbit)

        // encryption
        encryption "github.com/psavelis/team-pro/replay-api/pkg/infra/crypto"

        // container
        container "github.com/golobby/container/v3"

        // local files

        // ports
        common "github.com/psavelis/team-pro/replay-api/pkg/domain"
        metadata "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/services/metadata"

        replay_in "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/ports/in"
        replay_out "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/ports/out"

        steam_in "github.com/psavelis/team-pro/replay-api/pkg/domain/steam/ports/in"
        steam_out "github.com/psavelis/team-pro/replay-api/pkg/domain/steam/ports/out"

        iam_in "github.com/psavelis/team-pro/replay-api/pkg/domain/iam/ports/in"
        iam_out "github.com/psavelis/team-pro/replay-api/pkg/domain/iam/ports/out"

        // domain
        iam_entity "github.com/psavelis/team-pro/replay-api/pkg/domain/iam/entities"
        replay_entity "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/entities"
        steam_entity "github.com/psavelis/team-pro/replay-api/pkg/domain/steam/entities"

        // app
        cs_app "github.com/psavelis/team-pro/replay-api/pkg/app/cs"

        // usecases
        iam_use_cases "github.com/psavelis/team-pro/replay-api/pkg/domain/iam/use_cases"
        replay_use_cases "github.com/psavelis/team-pro/replay-api/pkg/domain/replay/use_cases"
        steam_use_cases "github.com/psavelis/team-pro/replay-api/pkg/domain/steam/use_cases"
)

type ContainerBuilder struct {
        Container container.Container
}

func NewContainerBuilder() *ContainerBuilder <span class="cov10" title="3">{
        c := container.New()

        b := &amp;ContainerBuilder{
                c,
        }

        err := c.Singleton(func() container.Container </span><span class="cov10" title="3">{
                return b.Container
        }</span>)

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to register *container.Container  in NewContainerBuilder.")
                panic(err)</span>
        }

        <span class="cov10" title="3">err = c.Singleton(func() *ContainerBuilder </span><span class="cov10" title="3">{
                return b
        }</span>)

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to register *ContainerBuilder in NewContainerBuilder.")
                panic(err)</span>
        }

        <span class="cov10" title="3">return b</span>
}

func (b *ContainerBuilder) Build() container.Container <span class="cov10" title="3">{
        return b.Container
}</span>

func (b *ContainerBuilder) WithEnvFile() *ContainerBuilder <span class="cov10" title="3">{
        if os.Getenv("DEV_ENV") == "true" </span><span class="cov0" title="0">{
                err := godotenv.Load()
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to load .env file")
                        panic(err)</span>
                }
        }

        <span class="cov10" title="3">err := b.Container.Singleton(func() (common.Config, error) </span><span class="cov10" title="3">{
                return EnvironmentConfig()
        }</span>)

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load EnvironmentConfig.")
                panic(err)</span>
        }

        <span class="cov10" title="3">return b</span>
}

func (b *ContainerBuilder) WithInboundPorts() *ContainerBuilder <span class="cov10" title="3">{
        c := b.Container

        err := c.Singleton(func() (replay_in.EventReader, error) </span><span class="cov10" title="3">{
                var gameEventReader replay_out.GameEventReader

                err := c.Resolve(&amp;gameEventReader)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve EventsByGameReader for EventsByGameService.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">return metadata.NewEventQueryService(gameEventReader), nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load EventsByGameReader.")
                panic(err)</span>
        }

        <span class="cov10" title="3">err = c.Singleton(func() (replay_in.UploadReplayFileCommand, error) </span><span class="cov10" title="3">{
                var gameEventReader replay_in.EventReader
                err := c.Resolve(&amp;gameEventReader)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve replay_in.EventReader for replay_in.UploadReplayFileCommand.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">var ReplayFileMetadataWriter replay_out.ReplayFileMetadataWriter
                err = c.Resolve(&amp;ReplayFileMetadataWriter)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve ReplayFileMetadataWriter for replay_in.UploadReplayFileCommand.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">var replayDataWriter replay_out.ReplayFileContentWriter
                err = c.Resolve(&amp;replayDataWriter)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve ReplayFileContentWriter for replay_in.UploadReplayFileCommand.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">return replay_use_cases.NewUploadReplayFileUseCase(ReplayFileMetadataWriter, replayDataWriter), nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to register replay_in.UploadReplayFileCommand with UploadReplayFileUseCase")
                panic(err)</span>
        }

        <span class="cov10" title="3">err = c.Singleton(func() (replay_in.ProcessReplayFileCommand, error) </span><span class="cov10" title="3">{
                var replayFileMetadataReader replay_out.ReplayFileMetadataReader
                err = c.Resolve(&amp;replayFileMetadataReader)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve ReplayFileMetadataReader for ProcessReplayFileCommand.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">var replayFileDataReader replay_out.ReplayFileContentReader
                err = c.Resolve(&amp;replayFileDataReader)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve ReplayFileContentReader for ProcessReplayFileCommand.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">var ReplayFileMetadataWriter replay_out.ReplayFileMetadataWriter
                err = c.Resolve(&amp;ReplayFileMetadataWriter)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve ReplayFileMetadataWriter for ProcessReplayFileCommand.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">var replayDataWriter replay_out.ReplayFileContentWriter
                err = c.Resolve(&amp;replayDataWriter)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve ReplayFileContentWriter for ProcessReplayFileCommand.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">var replayCommand replay_out.ReplayParser
                err = c.Resolve(&amp;replayCommand)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve ReplayParser for ProcessReplayFileCommand.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">var eventWriter replay_out.GameEventWriter
                err = c.Resolve(&amp;eventWriter)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve GameEventWriter for ProcessReplayFileCommand.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">return replay_use_cases.NewProcessReplayFileUseCase(replayFileMetadataReader, replayFileDataReader, ReplayFileMetadataWriter, replayDataWriter, replayCommand, eventWriter), nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load ProcessReplayFileCommand.")
                panic(err)</span>
        }

        <span class="cov10" title="3">err = c.Singleton(func() (replay_in.UpdateReplayFileHeaderCommand, error) </span><span class="cov10" title="3">{
                var eventReader replay_out.GameEventReader
                err = c.Resolve(&amp;eventReader)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve replay_out.GameEventReader for replay_in.UpdateReplayFileHeaderCommand.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">var replayFileMetadataReader replay_out.ReplayFileMetadataReader
                err = c.Resolve(&amp;replayFileMetadataReader)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve replay_out.ReplayFileMetadataReader for replay_in.UpdateReplayFileHeaderCommand.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">var replayFileMetadataWriter replay_out.ReplayFileMetadataWriter
                err = c.Resolve(&amp;replayFileMetadataWriter)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve ReplayFileMetadataWriter for UploadReplayFileCommand.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">return replay_use_cases.NewUpdateReplayFileHeaderUseCase(eventReader, replayFileMetadataReader, replayFileMetadataWriter), nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load replay_in.UpdateReplayFileHeaderCommand.")
                panic(err)</span>
        }

        <span class="cov10" title="3">err = c.Singleton(func() (replay_in.UploadAndProcessReplayFileCommand, error) </span><span class="cov10" title="3">{
                var uploadReplayFileCommand replay_in.UploadReplayFileCommand
                err = c.Resolve(&amp;uploadReplayFileCommand)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve UploadReplayFileCommand for UploadAndProcessReplayFileCommand.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">var processReplayFileCommand replay_in.ProcessReplayFileCommand
                err = c.Resolve(&amp;processReplayFileCommand)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve ProcessReplayFileCommand for UploadAndProcessReplayFileCommand.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">var updateReplayFileHeaderCommand replay_in.UpdateReplayFileHeaderCommand
                err = c.Resolve(&amp;updateReplayFileHeaderCommand)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve replay_in.UpdateReplayFileHeaderCommand for replay_in.UploadAndProcessReplayFileCommand.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">return replay_use_cases.NewUploadAndProcessReplayFileUseCase(uploadReplayFileCommand, processReplayFileCommand, updateReplayFileHeaderCommand), nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to register replay_in.UploadAndProcessReplayFileCommand.")
                panic(err)</span>
        }

        <span class="cov10" title="3">err = c.Singleton(func() (replay_in.ReplayFileMetadataReader, error) </span><span class="cov10" title="3">{
                var replayFileMetadataReader replay_out.ReplayFileMetadataReader
                err := c.Resolve(&amp;replayFileMetadataReader)

                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve replay_out.ReplayFileMetadataReader for replay_in.ReplayFileMetadataReader.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">return metadata.NewReplayFileQueryService(replayFileMetadataReader), nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to register replay_in.ReplayFileMetadataReader.")
                panic(err)</span>
        }

        <span class="cov10" title="3">err = c.Singleton(func() (replay_in.MatchReader, error) </span><span class="cov10" title="3">{
                var matchMetadataReader replay_out.MatchMetadataReader
                err := c.Resolve(&amp;matchMetadataReader)

                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve replay_out.MatchMetadataReader for replay_in.MatchReader.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">return metadata.NewMatchQueryService(matchMetadataReader), nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to register replay_in.MatchReader.")
                panic(err)</span>
        }

        <span class="cov10" title="3">err = c.Singleton(func() (steam_in.OnboardSteamUserCommand, error) </span><span class="cov10" title="3">{
                var steamUserWriter steam_out.SteamUserWriter
                err := c.Resolve(&amp;steamUserWriter)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve SteamUserWriter for OnboardSteamUserCommand.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">var steamUserReader steam_out.SteamUserReader
                err = c.Resolve(&amp;steamUserReader)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve SteamUserReader for OnboardSteamUserCommand.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">var vHashWriter steam_out.VHashWriter
                err = c.Resolve(&amp;vHashWriter)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve VHashWriter for OnboardSteamUserCommand.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">return steam_use_cases.NewOnboardSteamUserUseCase(steamUserWriter, steamUserReader, vHashWriter), nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load OnboardSteamUserCommand.", "err", err)
                panic(err)</span>
        }

        <span class="cov10" title="3">err = c.Singleton(func() (iam_in.CreateRIDTokenCommand, error) </span><span class="cov10" title="3">{
                var rIDWriter iam_out.RIDTokenWriter
                err := c.Resolve(&amp;rIDWriter)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve RIDWriter for OnboardRIDCommand.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">var rIDReader iam_out.RIDTokenReader
                err = c.Resolve(&amp;rIDReader)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve RIDReader for OnboardRIDCommand.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">return iam_use_cases.NewCreateRIDTokenUseCase(rIDWriter, rIDReader), nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load iam_in.CreateRIDTokenCommand.")
                panic(err)</span>
        }

        <span class="cov10" title="3">err = c.Singleton(func() (iam_in.VerifyRIDKeyCommand, error) </span><span class="cov10" title="3">{
                var rIDWriter iam_out.RIDTokenWriter
                err := c.Resolve(&amp;rIDWriter)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve RIDWriter for OnboardRIDCommand.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">var rIDReader iam_out.RIDTokenReader
                err = c.Resolve(&amp;rIDReader)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve RIDReader for OnboardRIDCommand.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">return iam_use_cases.NewVerifyRIDUseCase(rIDWriter, rIDReader), nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load iam_in.CreateRIDTokenCommand.")
                panic(err)</span>
        }

        <span class="cov10" title="3">return b</span>
}

func (b *ContainerBuilder) WithKafkaConsumer() *ContainerBuilder <span class="cov0" title="0">{
        // c := b.Container

        // err := c.Singleton(func() (out.KafkaConsumer, error) {
        //         consumer, err := kafka.NewConsumer(&amp;kafka.ConfigMap{
        //                 "bootstrap.servers":        "localhost:9092",
        //                 "acks":                     1,
        //                 "retries":                  0,
        //                 "retry.backoff.ms":         100,
        //                 "socket.timeout.ms":        6000,
        //                 "reconnect.backoff.max.ms": 3000,
        //         })
        //         if err != nil {
        //                 slog.Error(err.Error())
        //                 panic(err)
        //         }

        //         var config common.Config

        //         err := c.Resolve(&amp;config)
        //         if err != nil {
        //                 return nil, err
        //         }

        //         return kafka.NewKafkaConsumer(config.Kafka), nil
        // })

        // if err != nil {
        //         slog.Error("Failed to load KafkaConsumer.")
        //         panic(err)
        // }

        return b
}</span>

func InjectMongoDB(c container.Container) error <span class="cov10" title="3">{
        err := c.Singleton(func() (*mongo.Client, error) </span><span class="cov10" title="3">{
                var config common.Config

                err := c.Resolve(&amp;config)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve config for mongo.Client.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">mongoOptions := options.Client().ApplyURI(config.MongoDB.URI)
                ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
                defer cancel()

                client, err := mongo.Connect(ctx, mongoOptions)

                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to connect to MongoDB.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">return client, nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load mongo.Client.")
                return err
        }</span>

        // events repo
        <span class="cov10" title="3">err = c.Singleton(func() (*db.EventsRepository, error) </span><span class="cov10" title="3">{
                var config common.Config

                err := c.Resolve(&amp;config)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve config for db.EventsRepository.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">var client *mongo.Client
                err = c.Resolve(&amp;client)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve mongo.Client for db.EventsRepository as generic MongoDBRepository.", "err", err)
                        return &amp;db.EventsRepository{}, err
                }</span>

                <span class="cov10" title="3">repo := db.NewEventsRepository(client, config.MongoDB.DBName, replay_entity.GameEvent{}, "game_events")

                return repo, nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load NamedSingleton EventsRepository as generic MongoDBRepository.", "err", err)
                panic(err)</span>
        }

        <span class="cov10" title="3">err = c.Singleton(func() (replay_out.EventsByGameReader, error) </span><span class="cov10" title="3">{
                var repo *db.EventsRepository
                err = c.Resolve(&amp;repo)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve EventsRepository for replay_out.EventsByGameReader.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">return repo, nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load replay_out.EventsByGameReader.", "err", err)
                panic(err)</span>
        }

        <span class="cov10" title="3">err = c.Singleton(func() (replay_out.GameEventReader, error) </span><span class="cov10" title="3">{
                var repo *db.EventsRepository
                err = c.Resolve(&amp;repo)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve EventsRepository for replay_out.GameEventReader.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">return repo, nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load replay_out.GameEventReader.", "err", err)
                panic(err)</span>
        }

        <span class="cov10" title="3">err = c.Singleton(func() (replay_out.GameEventWriter, error) </span><span class="cov10" title="3">{
                var repo *db.EventsRepository
                err = c.Resolve(&amp;repo)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve EventsRepository for replay_out.GameEventWriter.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">return repo, nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to resolve replay_out.GameEventWriter.", "err", err)
                panic(err)</span>
        }

        // replay

        <span class="cov10" title="3">err = c.Singleton(func() (*db.ReplayFileMetadataRepository, error) </span><span class="cov10" title="3">{
                var client *mongo.Client
                err := c.Resolve(&amp;client)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve mongo.Client for NamedSingleton ReplayFileMetadataRepository as generic MongoDBRepository.", "err", err)
                        return &amp;db.ReplayFileMetadataRepository{}, err
                }</span>

                <span class="cov10" title="3">var config common.Config

                err = c.Resolve(&amp;config)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve config for db.ReplayFileMetadataRepository.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">repo := db.NewReplayFileMetadataRepository(client, config.MongoDB.DBName, replay_entity.ReplayFile{}, "replay_file_metadata")

                return repo, nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load NamedSingleton ReplayFileMetadataRepository as generic MongoDBRepository.", "err", err)
                panic(err)</span>
        }

        <span class="cov10" title="3">err = c.Singleton(func() (replay_out.ReplayFileMetadataReader, error) </span><span class="cov10" title="3">{
                var repo *db.ReplayFileMetadataRepository
                err = c.Resolve(&amp;repo)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve ReplayFileMetadataRepository for replay_out.ReplayFileMetadataReader.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">return repo, nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load replay_out.ReplayFileMetadataReader.", "err", err)
                panic(err)</span>
        }

        <span class="cov10" title="3">err = c.Singleton(func() (replay_out.ReplayFileMetadataWriter, error) </span><span class="cov10" title="3">{
                var repo *db.ReplayFileMetadataRepository
                err = c.Resolve(&amp;repo)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve SteamUserRepository for replay_out.ReplayFileMetadataWriter.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">return repo, nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load replay_out.ReplayFileMetadataWriter.", "err", err)
                panic(err)</span>
        }

        // MATCH METADATA
        <span class="cov10" title="3">err = c.Singleton(func() (*db.MatchMetadataRepository, error) </span><span class="cov10" title="3">{
                var client *mongo.Client
                err := c.Resolve(&amp;client)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve mongo.Client for NamedSingleton MatchMetadataRepository as generic MongoDBRepository.", "err", err)
                        return &amp;db.MatchMetadataRepository{}, err
                }</span>

                <span class="cov10" title="3">var config common.Config

                err = c.Resolve(&amp;config)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve config for db.MatchMetadataRepository.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">repo := db.NewMatchMetadataRepository(client, config.MongoDB.DBName, replay_entity.Match{}, "match_metadata")

                return repo, nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load NamedSingleton ReplayFileMetadataRepository as generic MongoDBRepository.", "err", err)
                panic(err)</span>
        }

        <span class="cov10" title="3">err = c.Singleton(func() (replay_out.MatchMetadataReader, error) </span><span class="cov10" title="3">{
                var repo *db.MatchMetadataRepository
                err = c.Resolve(&amp;repo)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve MatchMetadataRepository for replay_out.MatchMetadataReader.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">return repo, nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load replay_out.ReplayFileMetadataReader.", "err", err)
                panic(err)</span>
        }

        // content

        <span class="cov10" title="3">err = c.Singleton(func() (replay_out.ReplayFileContentWriter, error) </span><span class="cov10" title="3">{
                var client *mongo.Client

                err := c.Resolve(&amp;client)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve mongo.Client for ReplayFileContentWriter.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">var config common.Config

                err = c.Resolve(&amp;config)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve config for replay_out.ReplayFileContentWriter.", "err", err)
                        return nil, err
                }</span>

                // return s3.NewS3Adapter(config.S3), nil
                // return local_files.NewLocalFileAdapter(), nil
                <span class="cov10" title="3">return db.NewReplayFileContentRepository(client), nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load S3Adapter.", "err", err)
                panic(err)</span>
        }

        <span class="cov10" title="3">err = c.Singleton(func() (replay_out.ReplayFileContentReader, error) </span><span class="cov10" title="3">{
                var config common.Config

                err := c.Resolve(&amp;config)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve config for ReplayFileContentReader.", "err", err)
                        return nil, err
                }</span>

                // return blob.NewS3Adapter(config.S3), nil
                // return local_files.NewLocalFileAdapter(), nil

                <span class="cov10" title="3">var client *mongo.Client

                err = c.Resolve(&amp;client)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve mongo.Client for ReplayFileContentReader.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">return db.NewReplayFileContentRepository(client), nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load S3Adapter.")
                panic(err)</span>
        }

        <span class="cov10" title="3">err = c.Singleton(func() replay_out.ReplayParser </span><span class="cov10" title="3">{
                return cs_app.NewCS2ReplayAdapter()
        }</span>)

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load CS2ReplayAdapter.", "err", err)
                panic(err)</span>
        }

        // steam repo
        <span class="cov10" title="3">err = c.Singleton(func() (*db.SteamUserRepository, error) </span><span class="cov10" title="3">{
                var client *mongo.Client
                err := c.Resolve(&amp;client)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve mongo.Client for NamedSingleton SteamUserRepository as generic MongoDBRepository.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">var config common.Config

                err = c.Resolve(&amp;config)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve config for db.SteamUserRepository.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">repo := db.NewSteamUserMongoDBRepository(client, config.MongoDB.DBName, steam_entity.SteamUser{}, "steam_users")

                return repo, nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load NamedSingleton SteamUserRepository as generic MongoDBRepository.", "err", err)
                panic(err)</span>
        }

        <span class="cov10" title="3">err = c.Singleton(func() (steam_out.SteamUserWriter, error) </span><span class="cov10" title="3">{
                var repo *db.SteamUserRepository
                err = c.Resolve(&amp;repo)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve SteamUserRepository for steam_out.SteamUserWriter.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">return repo, nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load SteamUserWriter.", "err", err)
                panic(err)</span>
        }

        <span class="cov10" title="3">err = c.Singleton(func() (steam_out.SteamUserReader, error) </span><span class="cov10" title="3">{
                var repo *db.SteamUserRepository
                err = c.Resolve(&amp;repo)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve SteamUserRepository for steam_out.SteamUserReader.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">return repo, nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load SteamUserReader.", "err", err)
                panic(err)</span>
        }

        <span class="cov10" title="3">err = c.Singleton(func() (steam_out.VHashWriter, error) </span><span class="cov10" title="3">{
                var config common.Config

                err := c.Resolve(&amp;config)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve config for steam_out.VHashWriter.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">return encryption.NewSHA256VHasherAdapter(config.Auth.SteamConfig.VHashSource), nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load VHashWriter.", "err", err)
                panic(err)</span>
        }

        // end-steam

        // rid
        <span class="cov10" title="3">err = c.Singleton(func() (*db.RIDTokenRepository, error) </span><span class="cov10" title="3">{
                var client *mongo.Client
                err := c.Resolve(&amp;client)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve mongo.Client for NamedSingleton RIDTokenRepository as generic MongoDBRepository.", "err", err)
                        return &amp;db.RIDTokenRepository{}, err
                }</span>

                <span class="cov10" title="3">var config common.Config

                err = c.Resolve(&amp;config)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve config for db.SteamUserRepository.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">repo := db.NewRIDTokenRepository(client, config.MongoDB.DBName, iam_entity.RIDToken{}, "rid")

                return repo, nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load NamedSingleton RIDTokenRepository as generic MongoDBRepository.", "err", err)
                panic(err)</span>
        }

        <span class="cov10" title="3">err = c.Singleton(func() (iam_out.RIDTokenWriter, error) </span><span class="cov10" title="3">{
                var repo *db.RIDTokenRepository
                err = c.Resolve(&amp;repo)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve RIDTokenRepository for iam_out.RIDTokenWriter.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">return repo, nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load iam_out.RIDTokenWriter.", "err", err)
                panic(err)</span>
        }

        <span class="cov10" title="3">err = c.Singleton(func() (iam_out.RIDTokenReader, error) </span><span class="cov10" title="3">{
                var repo *db.RIDTokenRepository
                err = c.Resolve(&amp;repo)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to resolve RIDTokenRepository for iam_out.RIDTokenReader.", "err", err)
                        return nil, err
                }</span>

                <span class="cov10" title="3">return repo, nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load iam_out.RIDTokenReader.", "err", err)
                panic(err)</span>
        }

        <span class="cov10" title="3">return nil</span>
}

func (b *ContainerBuilder) With(resolver interface{}) *ContainerBuilder <span class="cov10" title="3">{
        c := b.Container

        err := c.Singleton(resolver)

        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to register resolver.", "err", err)
                panic(err)</span>
        }

        <span class="cov10" title="3">return b</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package ioc

import (
        "os"

        common "github.com/psavelis/team-pro/replay-api/pkg/domain"
)

func EnvironmentConfig() (common.Config, error) <span class="cov10" title="3">{
        config := common.Config{
                Auth: common.AuthConfig{
                        SteamConfig: common.SteamConfig{
                                SteamKey:    os.Getenv("STEAM_KEY"),
                                PublicKey:   os.Getenv("STEAM_PUB_KEY"),
                                Certificate: os.Getenv("STEAM_CERT"),
                                VHashSource: os.Getenv("STEAM_VHASH_SOURCE"),
                        },
                        BattleNetConfig: common.BattleNetConfig{
                                BattleNetKey: os.Getenv("BATTLENET_KEY"),
                        },
                        GitHubConfig: common.GitHubConfig{
                                GitHubKey: os.Getenv("GITHUB_KEY"),
                        },
                },
                MongoDB: common.MongoDBConfig{
                        URI:         os.Getenv("MONGO_URI"),
                        PublicKey:   os.Getenv("MONGO_PUB_KEY"),
                        Certificate: os.Getenv("MONGO_CERT"),
                        DBName:      os.Getenv("MONGO_DB_NAME"),
                },
        }

        return config, nil
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
